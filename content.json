{"meta":{"title":"RH","subtitle":null,"description":null,"author":"RH","url":"http://example.com"},"pages":[],"posts":[{"title":"SQLite表升级和导入","slug":"SQLite表升级和导入","date":"2021-04-15T06:31:00.000Z","updated":"2021-05-21T03:38:39.155Z","comments":true,"path":"2021/04/15/SQLite表升级和导入/","link":"","permalink":"http://example.com/2021/04/15/SQLite表升级和导入/","excerpt":"","text":"数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。1234567891011121314151617181920212223242526272829303132public class DBservice extends SQLiteOpenHelper &#123; private String CREATE_BOOK = &quot;create table book(bookId integer primarykey, bookName text);&quot;; private String CREATE_TEMP_BOOK = &quot;alter table book rename to _temp_book&quot;; private String INSERT_DATA = &quot;insert into book select *,&apos;&apos; from _temp_book&quot;; private String DROP_BOOK = &quot;drop table _temp_book&quot;; public DBservice(Context context, String name, CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; switch (newVersion) &#123; case 2: db.beginTransaction(); db.execSQL(CREATE_TEMP_BOOK); db.execSQL(CREATE_BOOK); db.execSQL(INSERT_DATA); db.execSQL(DROP_BOOK); db.setTransactionSuccessful(); db.endTransaction(); break; &#125; &#125; 打开外部数据库1234567891011121314151617181920212223242526272829303132333435public class DatabaseManager &#123; private DaoMaster mDaoMaster = null; private DaoSession otherDaoSession = null; private DatabaseManager() &#123; &#125; private static final class Holder &#123; private static final DatabaseManager INSTANCE = new DatabaseManager(); &#125; public static DatabaseManager getInstance() &#123; return Holder.INSTANCE; &#125; //获取外部其它数据库DaoSession DaoSession getOtherDaoSession(String dbName) &#123; //if (otherDaoSession == null) &#123; otherDaoSession = getDaoMaster(dbName).newSession(); //&#125; return otherDaoSession; &#125; private DaoMaster getDaoMaster(String dbName) &#123; if (dbName == null || TextUtils.isEmpty(dbName)) &#123; return null; &#125; //if (mDaoMaster == null) &#123; //mDaoMaster = new DaoMaster(new DaoMaster.DevOpenHelper(context, dbName).getWritableDb()); mDaoMaster = new DaoMaster(SQLiteDatabase.openDatabase(dbName, null, SQLiteDatabase.OPEN_READWRITE)); //&#125; return mDaoMaster; &#125;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"坐标、投影及坐标转换","slug":"坐标、投影及坐标转换","date":"2021-04-15T06:31:00.000Z","updated":"2021-05-14T07:19:18.584Z","comments":true,"path":"2021/04/15/坐标、投影及坐标转换/","link":"","permalink":"http://example.com/2021/04/15/坐标、投影及坐标转换/","excerpt":"","text":"1.坐标、投影及坐标转换坐标转换图 参考博客：https://zhuanlan.zhihu.com/p/34662114 2.epsg转换 3.飞控系统 dronekit ，dronekit-android 基准站使用原理(差分) 以地球角度看，移动站和基站准加载20公里以内都可以看做是同一位置。同一时间 同一位置对同一组卫星进行观测，大家都是穿过相同的大气、云层等这些‘固定’误差的地方（可以当作常数考虑），常数在方程中是可以抵消，所以你差分后得到的结果是已经抵消掉理论上所有环境上的误差 载波相位测量（英语：Carrier phase measurement） 利用卫星与接收器之间相对运动的关系，先取得卫星发射讯号时所产生的相位与接收器接收时所产生的参考相位，并求出两者之间的相位差值，即为载波观测量[1]。测量方法与虚拟距离相似，但虚拟距离是利用电码观测。 手机定位，GPS定位","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"Retrofit与Postman的对应关系","slug":"Retrofit网络请求 与 Postman","date":"2021-04-12T07:42:00.000Z","updated":"2021-05-21T03:39:17.267Z","comments":true,"path":"2021/04/12/Retrofit网络请求 与 Postman/","link":"","permalink":"http://example.com/2021/04/12/Retrofit网络请求 与 Postman/","excerpt":"","text":"1.postman里面的form-data对应 @Part 标签，上传数据。123456789@Multipart@POSTCall&lt;JsonObject&gt; post1(@Url String url, @PartMap Map&lt;String, RequestBody&gt; params, @PartMap Map&lt;String, MultipartBody.Part&gt; parts);实现：参数一：RequestBody name = RequestBody.create(MediaType.parse(&quot;application/form-data&quot;), name);参数二：RequestBody fileRQ = RequestBody.create(MediaType.parse(&quot;image/*&quot;), file);MultipartBody.Part part = MultipartBody.Part.createFormData(&quot;file&quot;, file.getName(), fileRQ); 2.postman里面的x-www-form-urlencoded对应 @Field，以表单形式提交数据123@FormUrlEncoded@POSTCall&lt;JsonObject&gt; post(@Url String url, @FieldMap Map&lt;String, Object&gt; params); 3.postman里面的raw对应@Body ,在body中以json或text字符串的形式提交数据123456789@POSTCall&lt;JsonObject&gt; post2(@Url String url, @Body RequestBody test);例子：RequestBody type = RequestBody.create(MediaType.parse(&quot;application/json&quot;), string);//或者不传RequestBody，直接传对象@POSTCall&lt;JsonObject&gt; post2(@Url String url, @Body Object o);例子：post(url，User),post(url，hashmap) 示例：123456789//将json数据打包成字符串一次性传输Gson gson = new GsonBuilder().disableHtmlEscaping().create();JSONObject object = new JSONObject(gson.toJson(entity));object.put(&quot;&quot;,&quot;&quot;);HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();hashMap.put(&quot;requestText&quot;, object.toString());service.post(url,hashmap);[JSONObject 和 JsonObject 的区别](https://blog.csdn.net/ceovip/article/details/77980832)","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"Handler机制","slug":"Handler机制","date":"2021-04-08T03:15:00.000Z","updated":"2021-05-14T09:01:00.574Z","comments":true,"path":"2021/04/08/Handler机制/","link":"","permalink":"http://example.com/2021/04/08/Handler机制/","excerpt":"","text":"整个消息的循环流程: 1.Handler 通 过 sendMessage() 发 送 消 息 Message 到 消 息 队 列 MessageQueue。 2.Looper 通过 loop()不断提取触发条件的 Message，并将 Message 交 给对应的 target handler 来处理。 3.target handler 调用自身的handleMessage()方法来处理 Message。 结论： 主线程创建的时候会创建一个MainLooper，并且进入循环。 线程的 Looper 不允许退出，ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的应用也就退出了。 loop死循环只是简单地处理轻量的消息操作，和ANR并没有关系。looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。也就说我们的代码其实就是在这个循环里面去执行的，当然不会阻塞了。 参考链接1 参考链接2","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"天地图","slug":"天地图","date":"2021-04-07T08:41:00.000Z","updated":"2021-05-14T09:11:12.208Z","comments":true,"path":"2021/04/07/天地图/","link":"","permalink":"http://example.com/2021/04/07/天地图/","excerpt":"","text":"坐标系：CGCS2000 常用图层：1.矢量底图2.影像底图 投影类型： 经纬度投影 球面墨卡托投影 注：不同投影类型的区别在于请求链接不同 》官网链接","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"AES加密、解密","slug":"AES加密、解密","date":"2021-03-30T10:26:00.000Z","updated":"2021-05-14T07:56:12.162Z","comments":true,"path":"2021/03/30/AES加密、解密/","link":"","permalink":"http://example.com/2021/03/30/AES加密、解密/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.southgnss.lj;import android.text.TextUtils;import android.util.Base64;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;public class AESEncrypt &#123; //偏移量 public static final String VIPARA = &quot;1234567812345678&quot;; //AES 为16位. DES 为8bytes //AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式 private static final String CBC_PKCS5_PADDING = &quot;AES/CBC/PKCS5Padding&quot;; //AES 加密 private static final String AES = &quot;AES&quot;; // SHA1PRNG 强随机种子算法, 要区别4.2以上版本的调用方法 private static final String SHA1PRNG = &quot;SHA1PRNG&quot;; //编码方式 public static final String CODE_TYPE = &quot;UTF-8&quot;; //AES加密需要密钥长度为16位，不够时默认可以用 \\0 补齐 public static final String key = &quot;123456789\\0\\0\\0\\0\\0\\0\\0&quot;; /** * 加密 * @param cleartext * @return */ public static String encrypt(String cleartext) &#123; return encrypt(key, cleartext); &#125; public static String encrypt(String key, String cleartext) &#123; if (TextUtils.isEmpty(cleartext)) &#123; return cleartext; &#125; try &#123; byte[] result = encrypt(key, cleartext.getBytes(CODE_TYPE)); return new String(Base64.encode(result, Base64.NO_WRAP), CODE_TYPE); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public static byte[] encrypt(String key, byte[] clear) throws Exception &#123; IvParameterSpec zeroIv = new IvParameterSpec(VIPARA.getBytes(CODE_TYPE)); /*byte[] raw = getRawKey(key.getBytes(&quot;utf-8&quot;)); SecretKeySpec skeySpec = new SecretKeySpec(raw, AES);*/ byte[] raw = key.getBytes(CODE_TYPE); SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;); Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING); cipher.init(Cipher.ENCRYPT_MODE, skeySpec, zeroIv); byte[] encrypted = cipher.doFinal(clear); return encrypted; &#125; /** * 解密 * * @param key * @param encrypted * @return */ public static String decrypt(String key, String encrypted) &#123; if (TextUtils.isEmpty(encrypted)) &#123; return encrypted; &#125; try &#123; byte[] enc = Base64.decode(encrypted.getBytes(CODE_TYPE), Base64.NO_WRAP); byte[] result = decrypt(key, enc); return new String(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public static byte[] decrypt(String key, byte[] encrypted) throws Exception &#123; IvParameterSpec zeroIv = new IvParameterSpec(VIPARA.getBytes(CODE_TYPE)); /* byte[] raw = getRawKey(key.getBytes()); SecretKeySpec skeySpec = new SecretKeySpec(raw, AES);*/ byte[] raw = key.getBytes(CODE_TYPE); SecretKeySpec skeySpec = new SecretKeySpec(raw, &quot;AES&quot;); Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING); cipher.init(Cipher.DECRYPT_MODE, skeySpec, zeroIv); byte[] decrypted = cipher.doFinal(encrypted); return decrypted; &#125;&#125;","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"使用Gson出现转译字符","slug":"使用Gson出现转译字符","date":"2021-03-30T05:10:05.000Z","updated":"2021-05-14T09:10:53.805Z","comments":true,"path":"2021/03/30/使用Gson出现转译字符/","link":"","permalink":"http://example.com/2021/03/30/使用Gson出现转译字符/","excerpt":"","text":"1.出现转译字符String s = new Gson().toJson(encodedText);出现转译字符 原因：Gson会把html标签，转换为Unicode转义字符。 正确的使用方法是:Gson gson = new GsonBuilder().disableHtmlEscaping().create(); 注意：用AES加密后的字符串转义后会变2.pache工具包common-lang进行html,xml,java等的转义与反转义123String str1 = StringEscapeUtils.unescapeJava(str);原始 str = &#123;\\&quot;name\\&quot;:\\&quot;spy\\&quot;,\\&quot;id\\&quot;:\\&quot;123456\\&quot;&#125;目标 str1 = &#123;&quot;name&quot;:&quot;spy&quot;,&quot;id&quot;:&quot;123456&quot;&#125; 下载地址：https://commons.apache.org/proper/commons-lang/download_lang.cgi","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"json","slug":"json","permalink":"http://example.com/tags/json/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"博客发布后自定义域名失效","slug":"博客发布后自定义域名失效","date":"2021-03-29T03:19:01.000Z","updated":"2021-03-29T03:20:03.906Z","comments":true,"path":"2021/03/29/博客发布后自定义域名失效/","link":"","permalink":"http://example.com/2021/03/29/博客发布后自定义域名失效/","excerpt":"","text":"1.博客发布后自定义域名失效https://blog.csdn.net/xs20691718/article/details/81873921 2.title标题中，冒号后面不能接空格，否则会报错","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/博客/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"NFC触碰连接蓝牙","slug":"NFC触碰连接蓝牙","date":"2021-03-25T10:38:00.000Z","updated":"2021-05-14T09:06:34.192Z","comments":true,"path":"2021/03/25/NFC触碰连接蓝牙/","link":"","permalink":"http://example.com/2021/03/25/NFC触碰连接蓝牙/","excerpt":"","text":"工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package com.southgnss.survx.device.nfc;import android.app.Activity;import android.app.PendingIntent;import android.content.Intent;import android.content.IntentFilter;import android.nfc.NdefMessage;import android.nfc.NdefRecord;import android.nfc.NfcAdapter;import android.nfc.tech.MifareClassic;import android.nfc.tech.NfcA;import android.os.Parcelable;import android.os.SystemClock;import android.text.TextUtils;import android.util.Log;import com.southgnss.library.device.ConnectListener;import com.southgnss.library.device.DeviceParManage;import com.southgnss.library.device.DeviceType;import com.southgnss.library.device.TopDataIOFactory;import com.southgnss.library.device.TopDeviceManage;import com.southgnss.library.device.message.FunctionEnablePar;import com.southgnss.library.util.ProgramConfigWrapper;import com.southgnss.survx.device.setting.StringManage;public class NfcUtils &#123; private NfcAdapter mNfcAdapter; private IntentFilter[] mIntentFilter = null; private PendingIntent mPendingIntent = null; private String[][] mTechList = null; private long lSetLocationSysTime = 0L; private static NfcUtils nfcUtils; public static NfcUtils getInstance(Activity activity) &#123; if (nfcUtils == null) &#123; synchronized (NfcUtils.class) &#123; if (nfcUtils == null) &#123; nfcUtils = new NfcUtils(activity); &#125; &#125; &#125; return nfcUtils; &#125; public NfcUtils(Activity activity) &#123; NfcInit(activity); mNfcAdapter = NfcAdapter.getDefaultAdapter(activity); &#125; /** * 首先，检查NFC是否打开 */ public boolean isEnabled() &#123; return mNfcAdapter != null &amp;&amp; mNfcAdapter.isEnabled(); &#125; /** * 初始化nfc设置 */ private void NfcInit(Activity activity) &#123; Intent intent = new Intent(activity, activity.getClass()); intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); mPendingIntent = PendingIntent.getActivity(activity, 0, intent, 0); //做一个IntentFilter过滤你想要的action 这里过滤的是ndef IntentFilter filter = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED); try &#123; filter.addDataType(&quot;*/*&quot;); &#125; catch (IntentFilter.MalformedMimeTypeException e) &#123; e.printStackTrace(); &#125; mTechList = new String[][]&#123;&#123;MifareClassic.class.getName()&#125;, &#123;NfcA.class.getName()&#125;&#125;; //生成intentFilter mIntentFilter = new IntentFilter[]&#123;filter&#125;; &#125; /** * 开启前台调度系统 */ public void enableForegroundDispatch(Activity activity) &#123; if (mNfcAdapter != null &amp;&amp; mIntentFilter != null) &#123; mNfcAdapter.enableForegroundDispatch(activity, mPendingIntent, mIntentFilter, mTechList); &#125; &#125; /** * 关闭前台调度系统 */ public void disableForegroundDispatch(Activity activity) &#123; if (mNfcAdapter != null &amp;&amp; mIntentFilter != null) &#123; mNfcAdapter.disableForegroundDispatch(activity); &#125; &#125; /** * 读取到的NFC数据 */ public void resolveIntent(Intent intent) &#123; if (SystemClock.elapsedRealtime() - lSetLocationSysTime &lt; 8000L) &#123; return; &#125; lSetLocationSysTime = SystemClock.elapsedRealtime(); String action = intent.getAction(); if (NfcAdapter.ACTION_TAG_DISCOVERED.equals(action) || NfcAdapter.ACTION_TECH_DISCOVERED.equals(action) || NfcAdapter.ACTION_NDEF_DISCOVERED.equals(action)) &#123; Parcelable[] rawArray = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES); NdefMessage[] msgs; //处理扫描蓝牙地址的 if (rawArray != null) &#123; msgs = new NdefMessage[rawArray.length]; for (int i = 0; i &lt; rawArray.length; i++) &#123; msgs[i] = (NdefMessage) rawArray[i]; &#125; for (final NdefRecord record : msgs[0].getRecords()) &#123; byte[] src = record.getPayload(); if (record.getPayload().length &lt; 36) &#123; return; &#125; StringBuilder macBuilder = new StringBuilder(); //解析蓝牙mac地址，倒过来放的 char[] buffer = new char[2]; for (int i = 7; i &gt; 1; i--) &#123; buffer[0] = Character.toUpperCase(Character.forDigit((src[i] &gt;&gt;&gt; 4) &amp; 0x0F, 16)); buffer[1] = Character.toUpperCase(Character.forDigit(src[i] &amp; 0x0F, 16)); macBuilder.append(buffer); if (i == 2) &#123; break; &#125; macBuilder.append(&quot;:&quot;); &#125; StringBuilder boothBuilder = new StringBuilder(); for (int i = 21; i &lt; src.length; i++) &#123; buffer[0] = Character.toUpperCase(Character.forDigit((src[i] &gt;&gt;&gt; 4) &amp; 0x0F, 16)); buffer[1] = Character.toUpperCase(Character.forDigit(src[i] &amp; 0x0F, 16)); boothBuilder.append(buffer); &#125; String strDeviceName = StringManage.decode(boothBuilder.toString()); String strDevice = strDeviceName + &quot;|&quot; + macBuilder.toString(); &#125; &#125; &#125; &#125; /** * 程序退出，释放 */ public void nfcRelease() &#123; if (mNfcAdapter != null) &#123; mNfcAdapter = null; &#125; if (nfcUtils != null) &#123; nfcUtils = null; &#125; &#125; public NfcAdapter getNfcAdapter() &#123; return mNfcAdapter; &#125; public IntentFilter[] getIntentFilter() &#123; return mIntentFilter; &#125; public PendingIntent getPendingIntent() &#123; return mPendingIntent; &#125; public String[][] getTechList() &#123; return mTechList; &#125; &#125; 使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends BaseActivity&#123;private NfcUtils nfcUtils; @Override public void initData() &#123; //nfc初始化设置 nfcUtils = NfcUtils.getInstance(this); &#125; @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); //当该Activity接收到NFC标签时，运行该方法 //调用工具方法，读取到的NFC数据 if (intent.getAction() != null &amp;&amp; intent.getAction().equalsIgnoreCase(&quot;android.nfc.action.NDEF_DISCOVERED&quot;)) &#123; setIntent(intent); if (nfcUtils != null) &#123; nfcUtils.resolveIntent(intent); &#125; return; &#125; &#125; @Override protected void onResume() &#123; super.onResume(); if (nfcUtils != null &amp;&amp; nfcUtils.isEnabled()) &#123; nfcUtils.enableForegroundDispatch(this); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if (nfcUtils != null &amp;&amp; nfcUtils.isEnabled()) &#123; nfcUtils.disableForegroundDispatch(this); &#125; &#125; @Override protected void onDestroy() &#123; if (nfcUtils != null ) &#123; nfcUtils.nfcRelease(); &#125; super.onDestroy(); &#125; &#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"synchronized与线程中断问题","slug":"synchronized与线程中断问题","date":"2021-03-25T03:30:00.000Z","updated":"2021-05-14T09:08:37.985Z","comments":true,"path":"2021/03/25/synchronized与线程中断问题/","link":"","permalink":"http://example.com/2021/03/25/synchronized与线程中断问题/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Uninterruptible &#123; private static final Object o1 = new Object(); public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new Thread(() -&gt; &#123; synchronized (o1) &#123; try &#123; System.out.println(&quot;start lock t1&quot;); Thread.sleep(20000); System.out.println(&quot;end lock t1&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; synchronized (o1) &#123; while (!isInterrupted()) &#123; try &#123; System.out.println(&quot;start lock t2&quot;); Thread.sleep(20000); System.out.println(&quot;end lock t2&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); //重新设置中断标示,因为抛出异常后中断标示会被清除。要想线程停止需要加上这一句 Thread.currentThread().interrupt(); &#125; &#125; &#125; &#125;); thread1.start(); // 中断线程的执行 thread1.interrupt(); //中断线程2 thread2.interrupt(); //锁死情况下，interrupt无效。 &#125;&#125;总结：1.要想中断线程需要在catch子句中，调用Thread.currentThread.interrupt()来设置中断状态（因为抛出异常后中断标示会被清除），让外界通过判断Thread.currentThread().isInterrupted()标示来决定是否终止线程还是继续下去，否者线程阻塞状态下是不会中断的。2.synchronized在获锁的过程中是不能被中断的，意思是说如果产生了死锁，则不可能被中断。与synchronized功能相似的reentrantLock.lock()方法也是一样，它也不可中断的，即如果发生死锁，那么reentrantLock.lock()方法无法终止，如果调用时被阻塞，则它一直阻塞到它获取到锁为止。3.线程管理推荐使用线程池，不直接使用 new Thread()。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}]},{"title":"Replugin插件化","slug":"Replugin插件化","date":"2021-03-24T03:37:00.000Z","updated":"2021-05-14T09:07:25.070Z","comments":true,"path":"2021/03/24/Replugin插件化/","link":"","permalink":"http://example.com/2021/03/24/Replugin插件化/","excerpt":"","text":"1.概念及技术分析1234Atlas:功能强大，完善。学习成本，接入成本比较高，适合门户型大型应用。Replugin：轻量级可快速使用的插件化框架，适合中小型应用。优点：API接近原生应用，只有一个hook点，兼容性好，不需要随着Android系统的升级进行后续的兼容。 2.学习总结12345678910111213141516171819202122232425262728293031321.getMergeAssetTask()不到解决： android-gradle-plugin:3.5.3 replugin-host-gradle:2.3.32.插件生成步骤: 1.正确配置repluginPluginConfig&#123;&#125; 2.Activity的正确继承 3../gradlew :rh_login:assembleDebug 4.改名为rh_login.jar 5.放到宿主工程中正确的位置3.宿主跳转插件activity Intent intent = RePlugin.createIntent(&quot;rh_login&quot;,&quot;com.example.LoginActivity&quot;); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); RePlugin.startActivity(this,intent);4.插件化开发广播发送和接收：与普通app开发完全一样，唯一要注意的是数据的传递5.插件间AIDL接口通讯： 1.AIDL接口中本身注意的一些事项 2.AIDL接口实现在对应的插件application中注册 3.通过RePlugin.fetchBinde获取对象去使用6.插件中启动前台services？RePlugin2.3.3版本还不支持,后台service正常，未来会提供7.插件间activity跳转不支持转场动画8.插件间fragment调用，直接通过RePlugin查找会报ClassCastException原因：不同classloader加载同一份类字节码，还是不同的class，所以他们的实例无法强转解决：通过compileOnly欺骗编译器，最总都使用宿主工程引入的类9.插件间无法去直接对外暴露View","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"Moudle library中添加aar","slug":"Moudle library中添加aar","date":"2021-03-13T06:29:00.000Z","updated":"2021-05-14T09:06:25.696Z","comments":true,"path":"2021/03/13/Moudle library中添加aar/","link":"","permalink":"http://example.com/2021/03/13/Moudle library中添加aar/","excerpt":"","text":"1.所在模块的build.gradle文件中123456789101112android &#123; repositories &#123; flatDir &#123; dirs &apos;libs&apos; &#125; &#125;&#125;dependencies &#123; implementation(name: &apos;lfilepickerlibrary-release&apos;, ext: &apos;aar&apos;)&#125; 2.多个模块引用时，项目的根build.gradle中统一添加12345678910allprojects &#123; repositories &#123; google() jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; flatDir &#123; dirs &apos;../dr_home/libs&apos; &#125; &#125;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"ButterKnife在lib中R2方式使用及配置","slug":"ButterKnife在lib中R2方式使用及配置","date":"2021-03-08T11:02:00.000Z","updated":"2021-05-14T09:03:53.903Z","comments":true,"path":"2021/03/08/ButterKnife在lib中R2方式使用及配置/","link":"","permalink":"http://example.com/2021/03/08/ButterKnife在lib中R2方式使用及配置/","excerpt":"","text":"配置ButterKnife 12345678910111.在全局的build.gradle中dependencies配置如下代码 classpath &apos;com.jakewharton:butterknife-gradle-plugin:*.*.*&apos;2.在lib build.gradle头部中添加如下代码：apply plugin: &apos;com.jakewharton.butterknife&apos;3.在lib build.gradle 中添加如下依赖，版本根据自己依赖而定，不是唯一 compile &apos;com.jakewharton:butterknife:*.*.*&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:*.*.*&apos;4.在lib中是使用ButterKnife ，手动把@bind中的R改成R2，这时候会报红，我们进行rebuild即 可。 注意点：library中switch-case的使用，在library中是不能使用switch- case 找id的，解决方法就是用if-else代替。 使用switch-case会报错。使用if-else还有一点注意。如图 使用体验：不推荐使用butterknife","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"Android特殊文字，形式","slug":"Android特殊文字，形式","date":"2021-03-08T07:00:00.000Z","updated":"2021-05-14T09:03:44.559Z","comments":true,"path":"2021/03/08/Android特殊文字，形式/","link":"","permalink":"http://example.com/2021/03/08/Android特殊文字，形式/","excerpt":"","text":"1.同一个字符串不同字体、颜色，SpannableString 2.自适应字体大小和文本宽度123android:autoSizeMaxTextSize=&quot;80dp&quot;android:autoSizeMinTextSize=&quot;2dp&quot;android:autoSizeTextType=&quot;uniform&quot;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"String特殊引用类型","slug":"String 特殊引用类型","date":"2021-03-05T03:25:00.000Z","updated":"2021-05-14T09:07:45.264Z","comments":true,"path":"2021/03/05/String 特殊引用类型/","link":"","permalink":"http://example.com/2021/03/05/String 特殊引用类型/","excerpt":"","text":"String为值类型还是引用类型？ 1234567891011121314151617181920//值类型int a = 1;int b = a;a = 2;Console.WriteLine(&quot;a is &#123;0&#125;,b is &#123;1&#125;&quot;, a, b);//字符串string str1 = &quot;ab&quot;;string str2 = str1;str1 = &quot;abc&quot;;Console.WriteLine(&quot;str1 is &#123;0&#125;,str2 is &#123;1&#125;&quot;, str1, str2);输出结果：//a is 2,b is 1//str1 is abc,str2 is abstr2依然是ab,并没有随str1的改变而改变。如果string是引用类型，按理Str1和Str指针都指向同一内存地址，如果Str的内容发生改变，Str1应该也会相应变化。此例子，看着string更像是值类型。 1234引用类型例子：String aa = new String(&quot;AA&quot;);这样定义，aa就是一个引用StringBuilder strb2 = new StringBuilder(&quot;BB&quot;); 结论： String是引用类型，只是编译器对其做了特殊处理。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"Android生成aar包时,引用的其它aar无法打包问题","slug":"aar再打包aar","date":"2021-03-03T08:50:00.000Z","updated":"2021-05-14T09:02:46.767Z","comments":true,"path":"2021/03/03/aar再打包aar/","link":"","permalink":"http://example.com/2021/03/03/aar再打包aar/","excerpt":"","text":"Add snippet below to your root build script file:12345678buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.kezong:fat-aar:1.3.4&apos; &#125;&#125; Add snippet below to the build.gradle of your android library:1apply plugin: &apos;com.kezong.fat-aar&apos; Step 2: Embed dependenciesDeclare embed for the dependencies you want to merge in build.gradle. The usage is similar to implementation, like this:12345678910111213141516171819dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: &apos;*.jar&apos;) // java dependency embed project(&apos;:lib-java&apos;) // aar dependency embed project(&apos;:lib-aar&apos;) // aar dependency embed project(&apos;:lib-aar2&apos;) // local full aar dependency, just build in flavor1 flavor1Embed project(&apos;:lib-aar-local&apos;) // local full aar dependency, just build in debug debugEmbed (name:&apos;lib-aar-local2&apos;, ext:&apos;aar&apos;) // remote jar dependency embed &apos;com.google.guava:guava:20.0&apos; // remote aar dependency embed &apos;com.facebook.fresco:fresco:1.11.0&apos; // don&apos;t want to embed in implementation(&apos;androidx.appcompat:appcompat:1.2.0&apos;)&#125; 地址：https://github.com/kezong/fat-aar-android","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"Android共享文件（FileProvider）","slug":"Android共享文件（FileProvider）","date":"2021-01-18T08:04:08.000Z","updated":"2021-05-14T09:03:36.623Z","comments":true,"path":"2021/01/18/Android共享文件（FileProvider）/","link":"","permalink":"http://example.com/2021/01/18/Android共享文件（FileProvider）/","excerpt":"","text":"说明：android 7.0以后需要使用FileProvider配置访问路径 1.添加 FileProvider 到 AndroidManifest.xml12345678910111213 &lt;!-- FileProvider配置访问路径，适配7.0及其以上 --&gt; &lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;$&#123;applicationId&#125;.provider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_path&quot;/&gt; &lt;/provider&gt;&lt;/application&gt; 12345678&lt;!--@xml/file_path--&gt;&lt;resources&gt; &lt;paths&gt; &lt;external-path path=&quot;&quot; name=&quot;Export&quot;/&gt; &lt;/paths&gt;&lt;/resources&gt; 2.分享123456789101112131415161718192021222324252627/** * 文件分享 */ protected void fileShare(String filePath) &#123; Intent shareIntent = new Intent(Intent.ACTION_SEND); shareIntent.setType(&quot;*/*&quot;); File file = new File(filePath); if (file.exists()) &#123; shareIntent.putExtra(Intent.EXTRA_STREAM, getFileUri(this, file)); &#125; shareIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); //设置分享列表的标题，并且每次都显示分享列表 startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;)); &#125;/*根据不同android版本使用不同的方式*/ private Uri getFileUri(Context context, File file) &#123; Uri uri; // 低版本直接用 Uri.fromFile if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123; uri = Uri.fromFile(file); &#125; else &#123; //使用 FileProvider 会在某些 app 下不支持（在使用FileProvider 方式情况下QQ不能支持图片、视频分享，微信不支持视频分享） uri = FileProvider.getUriForFile(context, context.getPackageName() + &quot;.provider&quot;, file); &#125; return uri; &#125; 注意： android:authorities和FileProvider.getUriForFile的content是一致的。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"ADB 网络调试（可解决逍遥模拟器连接问题）","slug":"ADB 网络调试（可解决逍遥模拟器连接问题)","date":"2020-11-11T02:56:08.000Z","updated":"2021-04-14T08:41:17.141Z","comments":true,"path":"2020/11/11/ADB 网络调试（可解决逍遥模拟器连接问题)/","link":"","permalink":"http://example.com/2020/11/11/ADB 网络调试（可解决逍遥模拟器连接问题)/","excerpt":"","text":"12345671.数据线连接手机到电脑（确保手机打开了USB调试功能，逍遥模拟器需要连接成功一次）2.AS Terminal中输入命令 adb tcpip 5555 ,执行成功后可以断开数据线（确保命令行中可以调用到adb,可能需要配置环境变量）3.AS Terminal中输入命 adb connect 手机ip:5555 , 例如我的是：adb connect 172.16.55.24:5555关机开启时仍然有效（IP未变的前提下）","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"Retrofit + okhttp 下载问题","slug":"Retrofit   okhttp 下载问题","date":"2020-08-05T09:45:00.000Z","updated":"2021-05-14T09:07:34.417Z","comments":true,"path":"2020/08/05/Retrofit   okhttp 下载问题/","link":"","permalink":"http://example.com/2020/08/05/Retrofit   okhttp 下载问题/","excerpt":"","text":"问题 使用retrofit，添加okhttp拦截器，平常的json返回正常，但下载文件时，文件不准确。 解决 原先：return response.newBuilder() .body(okhttp3.ResponseBody.create(mediaType, content)) .build(); 建议：直接返回chain.request()不做其它操作没有问题，不能更改return，后续会出问题。建议不打印response.body()或者暂时取消拦截器。 1234567891011121314151617181920212223private static Interceptor MY_LOGGING_INTERCEPTOR = new Interceptor() &#123; private String TAG = &quot;MY_LOGGING_INTERCEPTOR&quot;; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); long t1 = System.nanoTime(); okhttp3.Response response = chain.proceed(chain.request()); long t2 = System.nanoTime(); okhttp3.MediaType mediaType = response.body().contentType(); Log.d(TAG, &quot;intercept:返回的类型为： &quot; + mediaType); String content = response.body().string(); //printParams(request.body()); Log.d(TAG, &quot;-----LoggingInterceptor----- :\\nrequest url:&quot; + request.url() + &quot;\\ntime:&quot; + (t2 - t1) / 1e6d + &quot;\\nbody:&quot; + content + &quot;\\n&quot;); //下载文件会有问题 /*return response.newBuilder() .body(okhttp3.ResponseBody.create(mediaType, content)) .build();*/ &#125; &#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"okhttp 连续两次请求踩坑","slug":"okhttp 连续两次请求踩坑","date":"2020-08-05T09:30:00.000Z","updated":"2021-05-14T09:06:49.553Z","comments":true,"path":"2020/08/05/okhttp 连续两次请求踩坑/","link":"","permalink":"http://example.com/2020/08/05/okhttp 连续两次请求踩坑/","excerpt":"","text":"1.现象 APP只请求了一次，服务器显示有两次请求，回复了两次。结果网络拦截器中显示的服务器返回的response.body()是正确的，而retrofit2实际回调的response.body()是另一个返回结果。 2.原因okhttp拦截器中使用了两次chain.process()。这就请求了两次。 第二次返回其它的结果可能是因为你已经取过一次body用于打印log，因为body只能取一次，取了之后就置空了。真想提前查看body可以用peekbody方法，也可以使用httpLoggingIntercept这个库打印。 3.错误示例 12345678910111213141516private static Interceptor MY_LOGGING_INTERCEPTOR = new Interceptor() &#123; private String TAG = &quot;MY_LOGGING_INTERCEPTOR&quot;; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); long t1 = System.nanoTime(); okhttp3.Response response = chain.proceed(chain.request()); long t2 = System.nanoTime(); okhttp3.MediaType mediaType = response.body().contentType(); Log.d(TAG, &quot;intercept:返回的类型为： &quot; + mediaType); String content = response.body().string(); printParams(request.body()); Log.d(TAG, &quot;-----LoggingInterceptor----- :\\nrequest url:&quot; + request.url() + &quot;\\ntime:&quot; + (t2 - t1) / 1e6d + &quot;\\nbody:&quot; + content + &quot;\\n&quot;); return chain.proceed(chain.request()); &#125; 4.正确示例123456789101112131415161718private static Interceptor MY_LOGGING_INTERCEPTOR = new Interceptor() &#123; private String TAG = &quot;MY_LOGGING_INTERCEPTOR&quot;; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); long t1 = System.nanoTime(); okhttp3.Response response = chain.proceed(chain.request()); long t2 = System.nanoTime(); okhttp3.MediaType mediaType = response.body().contentType(); Log.d(TAG, &quot;intercept:返回的类型为： &quot; + mediaType); String content = response.body().string(); printParams(request.body()); Log.d(TAG, &quot;-----LoggingInterceptor----- :\\nrequest url:&quot; + request.url() + &quot;\\ntime:&quot; + (t2 - t1) / 1e6d + &quot;\\nbody:&quot; + content + &quot;\\n&quot;); return response.newBuilder() .body(okhttp3.ResponseBody.create(mediaType, content)) .build(); &#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"SVN分支合并","slug":"SVN分支合并","date":"2020-04-15T09:11:23.000Z","updated":"2021-04-07T08:47:23.122Z","comments":true,"path":"2020/04/15/SVN分支合并/","link":"","permalink":"http://example.com/2020/04/15/SVN分支合并/","excerpt":"","text":"1.SVN想要使用分支标记功能，需要在创建项目的时候创建三个文件夹 trunk (主干) branches (分支，主要用于新功能的开发) tags (标记，主要用于项目开发中的里程碑，比如开发到一定阶段可以单独一个版本作为发布等，它往往代表一个可以固定的完整的版本) 注意事项： 开发时为了避免branch和trunk冲突，需要branch不停地和trunk保持同步，即不停的合并trunk到branch。 正式合并前一定要先进行测试合并 合并branch到主干，只能进行一次。 分支主干合并的来源和Git使用相反，需要理解 合并trunk到branch需要当前处于branch仓库目录中。右键-合并-合并一个版本范围-合并的源选择trunk路径（所有版本，指定范围根据需要）-测试合并-合并 需要经常合并 合并branch到trunk需要当前处于trunk仓库目录。右键-合并-合并一个版本范围-合并的源选择branch路径（所有版本，指定范围根据需要）-测试合并-合并 此合并只可进行一次 合并分支步骤右键-TortoiseSVN-合并-合并一个版本范围-合并的源（输入你想要获取的代码的仓库地址，合并trunk到branch时选择trunk）-所有版本和指定范围根据需要选择-测试合并，有冲突时解决本地冲突，或删文件-合并","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"代码","slug":"代码","permalink":"http://example.com/tags/代码/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"Nginx服务器搭建","slug":"Nginx服务器编译安装","date":"2019-12-25T12:42:08.000Z","updated":"2021-04-08T03:17:12.298Z","comments":true,"path":"2019/12/25/Nginx服务器编译安装/","link":"","permalink":"http://example.com/2019/12/25/Nginx服务器编译安装/","excerpt":"","text":"1.下载1wget http://nginx.org/download/nginx-1.18.0.tar.gz 2.复制，解压123cp nginx-1.18.0.tar.gz /usr/local/tar -xzf nginx-1.18.0.tar.gzcd nginx-1.18.0 3.安装编译环境12yum updateyum install -y gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 4.编译安装123456789#添加用户和组groupadd wwwuseradd -g www www#配置./configure --prefix=/usr/local/nginx-1.18.0 --user=qgydevops --group=qgydevops --with-http_ssl_module --with-http_gzip_static_module --with-http_sub_module --with-http_stub_status_module（用户组可以不添加，不配置）#编译，安装make &amp;&amp; make instal 5.配置环境变量1234567vim /etc/profile.d/nginx.sh文件内写入：export NGINX_HOME=/usr/local/nginxexport PATH=$NGINX_HOME/sbin:$PATH保存文件退出执行：chmod +x /etc/profile.d/nginx.shsource /etc/profile.d/nginx.sh 6.修改配置文件1vim /usr/local/nginx/conf/nginx.conf 7.文件内添加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465user www;worker_processes 8; pid /usr/local/nginx/nginx.pid;worker_rlimit_nofile 65535;error_log /data/wwwlog/error_nginx.log crit;events &#123; use epoll; worker_connections 65535; multi_accept on;&#125;http &#123; limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; limit_conn_zone $binary_remote_addr zone=addr:10m; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; server_names_hash_bucket_size 128; client_header_buffer_size 512k; client_max_body_size 100m; client_body_buffer_size 10m; large_client_header_buffers 4 512k; sendfile on; tcp_nopush on; tcp_nodelay on; server_tokens off; keepalive_timeout 65; send_timeout 10; client_body_timeout 10; client_header_timeout 10; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; fastcgi_intercept_errors on; gzip on; gzip_min_length 256k; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_comp_level 6; gzip_proxied any; gzip_vary on; gzip_types text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml text/javascript application/javascript application/x-javascript text/x-json application/json application/x-web-app-manifest+json text/css text/plain text/x-component font/opentype application/x-font-ttf application/vnd.ms-fontobject image/x-icon; gzip_disable &quot;MSIE [1-6]\\.(?!.*SV1)&quot;; open_file_cache max=65535 inactive=20s; open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on; include vhost/*.conf;&#125; 8.http{}配置中添加1234567server &#123; listen 80; server_name 你的IP地址; root /home/RH; index index.html; &#125; 9.重启服务，配置生效1nginx –s reload 10.访问nginx，现在你可以通过公网ip (本地可以通过 localhost /或 127.0.0.1 ) 查看nginx 服务返回的信息。1curl -i localhost 11.修改文件夹权限，否则无法访问1chmod 777 RH 12.。浏览器访问 http://你的IP地址 设置开机启动13.在系统服务目录里创建nginx.service文件1vi /usr/lib/systemd/system/nginx.service 14.写入内容如下：1234567891011121314151617181920212223#服务的说明[Unit]#描述服务Description=nginx#描述服务类别After=network.target#服务运行参数的设置 [Service]#forking是后台运行的形式Type=forking#服务的具体运行命令ExecStart=/usr/local/nginx/sbin/nginx#重启命令ExecReload=/usr/local/nginx/sbin/nginx -s reload#停止命令ExecStop=/usr/local/nginx/sbin/nginx -s quit#表示给服务分配独立的临时空间PrivateTmp=true#运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3 [Install]WantedBy=multi-user.target 15.设置开机自启动1systemctl enable nginx.service 16.查看nginx状态1systemctl status nginx.service 17.重启nginx123pkill -9 nginxps aux | grep nginxsystemctl start nginx 18.查看服务状态1systemctl status nginx.service 备案访问问题：1.域名需要实名认证、 2.购买的国内云服务器。默认访问80端口，服务器需要备案，否则无法访问；访问非80端口不需要备案。 3.购买的国外云服务器。不需要备案。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/服务器/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}]},{"title":"搭建FTP服务器","slug":"搭建FTP服务器","date":"2019-12-25T11:41:24.000Z","updated":"2021-04-09T09:00:22.653Z","comments":true,"path":"2019/12/25/搭建FTP服务器/","link":"","permalink":"http://example.com/2019/12/25/搭建FTP服务器/","excerpt":"","text":"1.安装[root@Sungeek ~]# yum -y install vsftpd 1.编辑配置[root@Sungeek ~]# cd /etc/vsftpd[root@Sungeek ~]# vim vsftpd.conf 1234567891011//本地用户访问local_enable=YES#本地用户访问目录local_root=/home/FTP/#只允许在主目录下活动chroot_local_user=YES#匿名用户不能访问anonymous_enable=NO#匿名用户访问目录anon_root=/home/RH/JasonRH.github.io/index.html 3.添加FTP用户命令：useradd XXX设置FTP用户密码：passwd XXX设置用户目录访问权限：[root@Sungeek vsftpd]# chown -R ftpuser /home/ftp 3、设置vsftpd服务开机启动[root@Sungeek ~]# systemctl enable vsftpd.service //设置开机自启动systemctl enable vsftpd.service//启动ftp服务systemctl start vsftpd.service//暂停ftp服务systemctl status vsftpd.service//查看ftp服务端口netstat -antup | grep ftp重启服务service vsftpd restart 开启被动模式12345pasv_enable=YES # 是否允许数据传输时使用PASV模式（默认值为 YES）pasv_min_port=port port_number # PASV 模式下，数据传输使用的端口下界（0 表示任意。默认值为 0）把端口范围设在比较高的一段范围内，比如 50000-60000，将有助于安全性的提高.pasv_max_port=port_number # PASV 模式下，数据传输使用的端口上界（0 表示任意。默认值为 0）pasv_promiscuous=NO # 是否屏蔽对 PASV 进行安全检查，默认值为 NO（当有安全隧道时可禁用）pasv_address # PASV 模式中服务器传回的 ip 地址。默认值为 none，即地址是从呼入的连接套接字中获取。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/服务器/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}]},{"title":"Android Studio新建Module异常","slug":"Android Studio新建Module异常","date":"2019-12-10T01:40:23.000Z","updated":"2021-05-14T09:03:19.663Z","comments":true,"path":"2019/12/10/Android Studio新建Module异常/","link":"","permalink":"http://example.com/2019/12/10/Android Studio新建Module异常/","excerpt":"","text":"问题：新建module后，上面显示 Gradle sync 同步失败，build窗口一直卡在同步中，卸载重装 更换sdk，删除.gradle和 android配置文件夹都没有用 解决办法：由于开启了渐变同步导致，到设置界面： File → Settings → Experimental → Gradle 把Only sync the active variant 的勾去掉即可","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://example.com/tags/Android-Studio/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"Android Studio 配置签名和编译自命名","slug":"Android Studio 配置签名和编译自命名","date":"2019-09-07T01:16:00.000Z","updated":"2021-05-14T09:03:03.119Z","comments":true,"path":"2019/09/07/Android Studio 配置签名和编译自命名/","link":"","permalink":"http://example.com/2019/09/07/Android Studio 配置签名和编译自命名/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354android &#123;def releaseTime() &#123; return new Date().format(&quot;yyMMdd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;))&#125;signingConfigs &#123; myConfig &#123; storeFile file(RELEASE_STORE_FILE) storePassword RELEASE_KEY_PASSWORD keyAlias RELEASE_KEY_ALIAS keyPassword RELEASE_STORE_PASSWORD &#125; &#125; buildTypes &#123; release &#123; signingConfig signingConfigs.myConfig proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; //混淆 minifyEnabled true //Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true &#125; debug &#123; signingConfig signingConfigs.myConfig applicationIdSuffix &apos;.debug&apos; versionNameSuffix &apos;debug&apos; //混淆 minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; //Zipalign优化 zipAlignEnabled false // 移除无用的resource文件 shrinkResources false &#125; android.applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; def enName = &apos;阅读&apos; outputFileName = &quot;$&#123;enName&#125;_V$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;$&#123;name&#125;.apk&quot; &#125; &#125; &#125; &#125;···#注意：signingConfigs 要放在 buildTypes 前面 123456#gradle.properties文件中添加jks信息RELEASE_STORE_FILE=../release.jksRELEASE_STORE_PASSWORD=******RELEASE_KEY_ALIAS=**RELEASE_KEY_PASSWORD=****** 1#根据RELEASE_STORE_FILE 配置的路径，将release.jks 文件放到项目根目录下","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"Git乱码","slug":"Git乱码","date":"2019-08-06T01:40:23.000Z","updated":"2021-04-06T07:39:45.609Z","comments":true,"path":"2019/08/06/Git乱码/","link":"","permalink":"http://example.com/2019/08/06/Git乱码/","excerpt":"","text":"解决git bash 终端显示中文乱码要注意的是，这样设置后，你的git bash终端也要设置成中文和utf-8编码。才能正确显示中文，例如对比如下： 在git bash的界面中右击空白处，弹出菜单，选择选项-&gt;文本-&gt;本地Locale，设置为zh_CN，而旁边的字符集选框选为UTF-8。 英文显示则是：Options-&gt;Text-&gt;Locale改为zh_CN，Character set改为UTF-8 通过修改配置文件来解决中文乱码如果你的git bash终端没有菜单选项显示，还可以通过直接修改配置文件的方式来解决中文乱码问题。 进入git的安装目录 编辑etc\\gitconfig文件，也有些windows系统是存放在C:\\Users\\Administrator.gitconfig路径或安装盘符:\\Git\\mingw64\\etc\\gitconfig，在文件末尾增加以下内容：[gui] encoding = utf-8 # 代码库统一使用utf-8 [i18n] commitencoding = utf-8 # log编码 [svn] pathnameencoding = utf-8 # 支持中文路径 [core] quotepath = false # status引用路径不再是八进制（反过来说就是允许显示中文了） 版权声明：本文为CSDN博主「铁乐与猫」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u012145252/article/details/81775362","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/其他/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/其他/"}]},{"title":"Android和PHP，字符压缩和编码","slug":"字符串压缩编码","date":"2019-07-11T05:11:23.000Z","updated":"2021-05-14T09:11:39.554Z","comments":true,"path":"2019/07/11/字符串压缩编码/","link":"","permalink":"http://example.com/2019/07/11/字符串压缩编码/","excerpt":"","text":"base64_encode(gzdeflate(源字符串)) Android字符压缩12345678910111213141516171819202122232425262728293031public static byte[] deflater(String data) &#123; //ByteArrayInputStream inputStream = new ByteArrayInputStream(data.getBytes()); //内存输出流 ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); // 要使用no_wrap的Deflater，php才能解压，9是最高的压缩级别，可以设置为1-9的级别，1速度最快 DeflaterOutputStream deflaterOut = new DeflaterOutputStream(outputStream, new Deflater(9, true)); try &#123; deflaterOut.write(data.getBytes()); //一定要finish否则长度为0 deflaterOut.finish(); outputStream.flush(); //String str = outputStream.toString(); byte[] byteArray = outputStream.toByteArray(); return byteArray; &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; finally &#123; try &#123; //inputStream.close(); deflaterOut.close(); outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Android Base64编码1234567891011121314public static String enncode(String s) &#123; byte[] bytes; String encodeString = null; try &#123; bytes = s.getBytes(\"UTF-8\"); encodeString = Base64.encodeToString(bytes, Base64.NO_WRAP) //java中使用（需要jdk8） //Base64.getEncoder().encodeToString(\"some string\".getBytes(\"utf-8\")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return encodeString;&#125; PHP 解码与解压缩 123$Code = '这里填写要解密的编码'; // base64编码 $Temp = base64_decode($Code); $postStr = gzinflate($Temp); 参考网址：https://blog.csdn.net/hdgcx/article/details/53916837","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"数据压缩","slug":"数据压缩","permalink":"http://example.com/tags/数据压缩/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"json数据","slug":"json数据","date":"2019-07-10T05:10:05.000Z","updated":"2021-05-14T09:06:13.456Z","comments":true,"path":"2019/07/10/json数据/","link":"","permalink":"http://example.com/2019/07/10/json数据/","excerpt":"","text":"1.出现转译字符 String s = new Gson().toJson(encodedText);出现转译字符 原因：Gson会把html标签，转换为Unicode转义字符。 正确的使用方法是:Gson gson = new GsonBuilder().disableHtmlEscaping().create();","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"json","slug":"json","permalink":"http://example.com/tags/json/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"FFmpeg视频工具","slug":"FFmpeg","date":"2019-06-10T05:00:00.000Z","updated":"2021-05-14T09:04:30.063Z","comments":true,"path":"2019/06/10/FFmpeg/","link":"","permalink":"http://example.com/2019/06/10/FFmpeg/","excerpt":"","text":"FFmpeg是非常强大的多媒体视频处理工具。功能包括视频采集功能、视频格式转换、视频抓图、给视频加水印等。下载地址：https://ffmpeg.org/ 命令1080P转720P ./ffmpeg -i A.mp4 -c copy -c:v libx264 -vf scale=-2:720 B.mp4 mp3转换pcm ./ffmpeg -y -i test.mp3 -acodec pcm_s16le -f s16le -ac 1 -ar 16000 16k.pcm 参数 说明 -y 允许覆盖 -i test.mp3 源文件 -acodec pcm_s16le 编码器 -f s16le 强制文件格式 -ac 2 双声道 -ar 16000 采样率 pcm转mp3 ffmpeg -y -f s16be -ac 2 -ar 16000 -acodec pcm_s16le -i 16k.pcm new_mp3.mp3 pcm播放 ./ffplay -ar 16000 -channels 1 -f s16le -i xxx.pcm MP3截取 ffmpeg -y -i test.mp3 -ss 00:00:00 -t 00:00:03 -acodec copy output_mp3.mp3 参数 说明 -y 允许覆盖 -i test.mp3 源文件 -ss 00:00:00 开始时间 -t 00:00:03 结束时间 -acodec copy 编码格式复制","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"视频","slug":"视频","permalink":"http://example.com/tags/视频/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"Linux scp命令","slug":"Linux scp命令","date":"2019-05-22T05:00:00.000Z","updated":"2021-03-29T03:01:27.428Z","comments":true,"path":"2019/05/22/Linux scp命令/","link":"","permalink":"http://example.com/2019/05/22/Linux scp命令/","excerpt":"","text":"Linux scp命令Linux scp命令用于Linux之间复制文件和目录。 scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。 scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file][-l limit] [-o ssh_option] [-P port] [-S program][[user@]host1:]file1 [...] [[user@]host2:]file2 简易写法: scp [可选参数] file_source file_target 参数说明： -1： 强制scp命令使用协议ssh1 -2： 强制scp命令使用协议ssh2 -4： 强制scp命令只使用IPv4寻址 -6： 强制scp命令只使用IPv6寻址 -B： 使用批处理模式（传输过程中不询问传输口令或短语） -C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p：保留原文件的修改时间，访问时间和访问权限。 -q： 不显示传输进度条。 -r： 递归复制整个目录。 -v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit： 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式， -P port：注意是大写的P, port是指定数据传输用到的端口号 -S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 1.将文件从中间服务器拷贝到远程Android设备 scp local_file remote_username@remote_ip:remote_folder 或scp local_file remote_ip:remote_folder 例：scp -i /root/id_rsa -P 60048 /root/RH/v2.0.75.apk root@127.0.0.1:/sdcard/Box/apk/ 2.将文件从远程Android设备拷贝到中间Linux服务器（调换后面两个参数位置） scp -i /root/id_rsa -P 2313 root@127.0.0.1:/data/data/com.example.test/databases/test.db /root/RH/","categories":[],"tags":[{"name":"指令","slug":"指令","permalink":"http://example.com/tags/指令/"}],"keywords":[]},{"title":"Android,Linux常用指令","slug":"常用指令","date":"2019-05-20T06:20:00.000Z","updated":"2021-05-14T09:09:40.750Z","comments":true,"path":"2019/05/20/常用指令/","link":"","permalink":"http://example.com/2019/05/20/常用指令/","excerpt":"","text":"文件操作adb 查看文件详细信息： ls –l pull文件 adb pull sdcard/Box/log/log_2019-04-24.log 2019-01-24.log push文件： adb push C:/Users/EDZ/Desktop/test.db data/data/com.example.test/databases/ 查看文件： cat file 修改文件别名 adb shell ln -s [源文件] [目标文件] 删除system/avi.apk: adb shell rm /system/avi.apk 删除文件夹及其下面所有文件： adb shell rm -r &lt;folder&gt; 强制删除当前目录下的所有文件及目录 adb shell rm -rf * 设置文件权限： adb shell chmod 777 /system/fonts/DroidSansFallback.ttf 新建文件夹： adb shell mkdir path/foldelname 新建文件夹 上层目录不存在则创建上层目录(path) adb shell mkdir -p path/foldelname 查看文件内容： adb shell cat &lt;file&gt; 创建了一个空文本文件 touch text.txt 查看wifi密码： adb shell cat /data/misc/wifi/*.conf vim编辑文件创建并打开编辑一个文件（android系统下需要安装busybox才能使用vi编辑） busybox-armv7l vi 1.txt 退出编辑模式 esc 保存并退出 :wq 不保存强制退出 :q! APK操作查看log： adb logcat 安装apk adb install C:/Users/EDZ/Desktop/Android_sign.apk 卸载apk adb uninstall com.example.test 启动应用： adb shell am start &lt;package_name&gt;/&lt;activity_class_name&gt; 覆盖安装 adb install -r xxx.apk 查看apk详细信息 adb shell dumpsys package com.example.test pm指令安装 pm install sdcard/Box/apk/v2.0.75.apk 卸载 pm uninstall com.example.test 静默安装 pm install -r /xx/xxx.apk 查看已有程序包名 adb shell pm list packages 清除APK数据 adb shell pm clear &lt;PACKAGE&gt; am指令am start com.example.test/com.example.test.activity.LaunchActivity am force-stop com.example.test am start com.example.test/com.example.test.activity.LaunchActivity am force-stop com.example.test am start com.example.test/com.example.test.activity.LaunchActivity 权限可读写权限 mount -o remount,rw /system 只读权限 mount -o remount,ro /system pythonimport os import time os.system('adb root'); time.sleep(2); #将 '/system' 部分置于可写入的模式 os.system('adb remount'); //查看系统信息adb shell cat /system/build.prop","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"指令","slug":"指令","permalink":"http://example.com/tags/指令/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"Git","slug":"Git","date":"2019-05-13T08:00:00.000Z","updated":"2021-03-29T03:01:27.424Z","comments":true,"path":"2019/05/13/Git/","link":"","permalink":"http://example.com/2019/05/13/Git/","excerpt":"","text":"打 tag git tag v2.0.88 git push origin v2.0.88 创建分支 git branch gravity_test 查看分支 git branch 切换分支 git checkout gravity_test 提交代码 1.git add .(git add -A) 2.git commit -m &quot;&quot; 3.git push origin gravity_test git commit 编写提交信息 1.Insert+信息 2.Esc : wq Enter 暂存 #储藏 git stash git stash list #释放最后一次stash的数据并将其从list中移除 git stash pop #将你指定版本号为stash@{1}的工作取出来 git stash pop stash@{1}","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}],"keywords":[]},{"title":"Windows路由删除后出现的问题","slug":"Windows路由删除后出现的问题","date":"2019-04-24T03:08:30.000Z","updated":"2021-03-29T03:21:39.799Z","comments":true,"path":"2019/04/24/Windows路由删除后出现的问题/","link":"","permalink":"http://example.com/2019/04/24/Windows路由删除后出现的问题/","excerpt":"","text":"错误:Protocol family unavailable和connect:network is unreachable 原由：在Windows中 进行路由重置操作 route -f 现象：1.Android Studio 项目无法编译，报错 ERROR: Protocol family unavailable2.路由删除后重新连上网，Shadowsocks无法翻墙，国内网络可以上 解决：1.参照网上经验 关防火墙，然后重启as，没用。2.在环境变量添加：_JAVA_OPTIONS 值为：-Djava.net.preferIPv4Stack=true此时Android Studio出现新的错误connect: network is unreachable ,还是无法翻墙3.以管理员身份运行 命令提示符，键入netsh winsock reset，再重启电脑 。正解，问题解决！","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"Java数据转换","slug":"Java数据转换","date":"2019-04-08T05:30:35.000Z","updated":"2021-05-14T09:05:47.070Z","comments":true,"path":"2019/04/08/Java数据转换/","link":"","permalink":"http://example.com/2019/04/08/Java数据转换/","excerpt":"","text":"基本Java类型转换Java类型转换分为自动转换和强制转换两种。 基本类型间的自动类型转换需要满足以下条件: (1)转换双方的类型必须兼容，例如int和long类型就是兼容的，而int和boolean就是不兼容的。 (2)只能是”窄类型”向”宽类型”转换,也就是目标类型的数据表示范围要比源类型的数据表示范围要大。 byte–&gt;short–&gt;int–&gt;long float–&gt;double 按照箭头可以实现自动类型转换，而如果是相反方向间的类型转换则需要强制类型转换（强制转换会造成精度缺失）. 数值常量默认类型(1)Java中整型常量数值的默认类型是int类型，如果需要声明long类型的常量 ，需要在数值加上’l’或者’L’. 例如:int i = 3; long l = 3L; (2)Java中的浮点型常量数值默认是double类型，如果要声明一个数值为float型，则需要在数值后面加上’f’或者’F’. Float = 3.4是错误的 ，高级向低级转换用强转 1 byte (字节)= 8 bit (八个二进制数)char = 2 byteshort = 2 byteint = 4 bytelong = 4|8 bytefloat = 4 bytedouble = 8 bytef short SF = 0xC8;int data = 200;则 data == SF 成立 byte 转 intb[i] &amp; 0xFF运算后得出的仍然是个int,那么为何要和 0xFF进行与运算呢? 将byte强转为int不行吗?答案是不行的. 其原因在于: 计算机中数据按照补码存储 byte是8位，int是32位，byte转换为int后是32位，如果不和0xff进行与运算， 如果不进行&amp;0xff，那么当一个byte会转换成int时，由于int是32位，而byte只有8位这时会进行补位， byte=-1 原码 1000 0001 ，反码1111 1110 ，补码1111 1111 转换为32位int时的补码则为 1111 1111 1111 1111 1111 1111 1111 1111 ，呵呵！即0xffffffff，但是这个数是不对的，这种补位就会造成误差。 和0xff相与后，高24比特就会被清0了，结果就对了。 1111 1111 1111 1111 1111 1111 1111 1111&amp;0xff = 1111 1111 1111 1111 1111 1111 1111 1111 &amp; 0000 0000 0000 0000 0000 0000 1111 1111 = 0000 0000 0000 0000 0000 0000 1111 1111 (补码) -&gt;0000 0000 0000 0000 0000 0000 1111 1111（原码）= 255（int 十进制） byte为负数，高3字节就填充1，整数就补0，所以，如果byte是正数那么是否进行&amp;0xff结果都一样；如果是负数就一定需要&amp;0xff 计算机基础理论计算机运算时是将原码转成补码，用补码进行运算，最后再将运算结果转换成原码 byte是一个字节保存的，有8个位，即8个0、1。 8位的第一个位是符号位， 也就是说0000 0001代表的是数字1 1000 0001代表的就是-1 所以正数最大位0111 1111，也就是数字127 负数最大为1111 1111，也就是数字-128 上面说的是二进制原码，但是在java中采用的是补码的形式，下面介绍下什么是补码 1、反码： 一个数如果是正，则它的反码与原码相同； 一个数如果是负，则符号位为1，其余各位是对原码取反； 2、补码：利用溢出，我们可以将减法变成加法 对于十进制数，从9得到5可用减法： 9－4＝5 因为4+6＝10，我们可以将6作为4的补数 改写为加法： 9+6＝15（去掉高位1，也就是减10）得到5. 对于十六进制数，从c到5可用减法： c－7＝5 因为7+9＝16 将9作为7的补数 改写为加法： c+9＝15（去掉高位1，也就是减16）得到5. 在计算机中，如果我们用1个字节表示一个数，一个字节有8位，超过8位就进1，在内存中情况为（100000000），进位1被丢弃。 ⑴一个数为正，则它的原码、反码、补码相同 ⑵一个数为负，刚符号位为1，其余各位是对原码取反，然后整个数加1 1的原码为 10000001 1的反码为 11111110 1 1的补码为 11111111 0的原码为 00000000 0的反码为 11111111（正零和负零的反码相同） +1 0的补码为 100000000（舍掉打头的1，正零和负零的补码相同）","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}],"tags":[{"name":"数据转换","slug":"数据转换","permalink":"http://example.com/tags/数据转换/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}]},{"title":"题集","slug":"面试题集","date":"2019-03-26T02:32:27.000Z","updated":"2021-05-14T09:10:13.136Z","comments":true,"path":"2019/03/26/面试题集/","link":"","permalink":"http://example.com/2019/03/26/面试题集/","excerpt":"","text":"1.java的几种引用类型及区别 2.简述newSingleThreadExecutor()，newFixedThreadPool(int mThread),newCachedThreadPool(),newScheduledThreadPool(5) 3.什么是内部类？静态内部类和非静态内部类的区别。 4.onMeasure(),onLayout(),onDraw()的使用顺序和各自实现内容。 5.ANR出现情况，怎样查找？，怎样解决？ 6.OOM出现原因，怎样解决？ 7.Android 事件分发 8.视图动画和属性动画的区别 9.自然排序 10.进程间通讯方式 11.线程间通讯方式 12.线程间即时通讯技术 1.抽象类和接口的区别 2.什么时候使用抽象类，什么时候使用接口 3.List、Set、Map的区别 4.mybatis的SqlSession如何保证线程安全 5.Collections提供的工具方法 6.String、StringBuffer和StringBuilder区别 7.Map的键和值可以为null吗？为什么 8.集合排序、内排序、外排序简单Demo 9.封装、继承、多态 10.堆和栈的区别 11.设计模式 1.Android中常用的四个布局 2.横竖屏切换时Activity的生命周期 3.Padding和Margin有什么区别 4.ListView如何提高其效率？ 5.activity生命周期 6.Fragment生命周期 6.写一个单例模式 1.2&lt;&lt;3=__ 2.4&amp;5=__ 3.线程安全的List有__ ，线程安全的Map有 __ . 4.快速排序的时间复杂度为O(___)。 5.Service 的启动方式有_和 6.Activity的启动模式有 、 、 、 四种 7.BroadCastReciever 的注册方式分为__ 和_ _ . 8.Android 6.0 蓝牙编程除了蓝牙相关权限外还需要___ 权限。 9.BLE数据一次最大传输 ___ 字节。 10.SparseArray 的key是 ___ 类型。 11.Intent 传递对象时，对象需要实现 ___ 接口。 在Canvas 中，画圆的方法是 ,旋转的方法是 _ 。 Jni 里面，java 类型 char[] 对应本地类型 ____ 14,写一个单例Demo 15. 1234567891011121314151617181920212223242526272829public class Test &#123; static &#123; System.out.print(\"A\"); &#125; &#123; System.out.print(\"B\"); &#125; public Test() &#123; System.out.print(\"C\"); &#125;&#125;class Demo &#123; public static void main(String[] args) &#123; new Test(); new Test(); &#125;&#125;//ABCBC 16 123456789101112131415161718public String my_data = \"Lonbon Inc.\"; public static void main(String args[]) &#123; //System.out.println(\"Welcome to \" + my_data);//陷阱，调用不了 System.out.println(2 + 3 + \"4\"); System.out.println(\"4\" + 2 + 3); String abc = \"abc\"; String def = \"def\"; if ((abc + def) == \"abcdef\") &#123; System.out.println(\"Good!\"); &#125; else &#123; System.out.println(\"Bad!\"); &#125; &#125;//54 ，423，Bad!","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"其它","slug":"其它","permalink":"http://example.com/tags/其它/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2019-02-18T03:11:48.000Z","updated":"2021-05-14T09:10:25.151Z","comments":true,"path":"2019/02/18/深拷贝与浅拷贝/","link":"","permalink":"http://example.com/2019/02/18/深拷贝与浅拷贝/","excerpt":"","text":"浅拷贝只复制对象的引用，两个引用仍然指向同一个对象，在内存中占用同一块内存； 被复制对象的所有变量都含有与原来的对象相同的值，该对象内容被改变原对象内容也会相应的改变； 深拷贝被复制对象的所有变量都含有与原来的对象相同的值，但两者已经没有关联； 被复制的对象内容发生改变，原对象内容并不会发生改变； 1.浅拷贝“=”：示例: 1234567891011121314public static void test1() &#123; Map&lt;String, String&gt; m1 = new HashMap&lt;String, String&gt;(); Map&lt;String, String&gt; m2 = new HashMap&lt;String, String&gt;(); //放基本类型数据 m2.put(\"name\", \"11\"); //浅拷贝 m2 = m1; System.out.println(\"改变前m1:\" + m1); System.out.println(\"改变前m2:\" + m2); //改变 m2.put(\"age\", \"22\"); System.out.println(\"改变后m1:\" + m1); System.out.println(\"改变后m2:\" + m2); &#125; 改变前m1:{}改变前m2:{}改变后m1:{age=22}改变后m2:{age=22} 2.非真正深拷贝“putAll()”putAll仅对基本数据类型起到深拷贝的作用 示例： 12345678910111213public static void test2() &#123; Map&lt;String, String&gt; m1 = new HashMap&lt;String, String&gt;(); Map&lt;String, String&gt; m2 = new HashMap&lt;String, String&gt;(); //放基本类型数据 m2.put(\"name\", \"11\"); //类似深拷贝,putAll仅对基本数据类型起到深拷贝的作用。 m2.putAll(m1); System.out.println(\"改变前m1:\" + m1); System.out.println(\"改变前m2:\" + m2); m2.put(\"age\", \"22\"); System.out.println(\"改变后m1:\" + m1); System.out.println(\"改变后m2:\" + m2); &#125; 改变前m1:{}改变前m2:{name=11}改变后m1:{}改变后m2:{name=11, age=22} 1234567891011121314151617public static void test3() &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(100); list.add(200); Map&lt;String, Object&gt; m1 = new HashMap&lt;String, Object&gt;(); Map&lt;String, Object&gt; m2 = new HashMap&lt;String, Object&gt;(); //放对象 m1.put(\"list\", list); //浅拷贝,putAll仅对基本数据类型起到深拷贝的作用。 m2.putAll(m1); System.out.println(\"改变前m1:\" + m1); System.out.println(\"改变前m2:\" + m2); //改变对象 list.add(300); System.out.println(\"改变后m1:\" + m1); System.out.println(\"改变后m2:\" + m2); &#125; 改变前m1:{list=[100, 200]}改变前m2:{list=[100, 200]}改变后m1:{list=[100, 200, 300]}改变后m2:{list=[100, 200, 300]} 3.真正深拷贝有一种方法，是使用序列化的方式来实现对象的深拷贝，但是前提是，对象必须是实现了Serializable接口才可以，Map本身没有实现 Serializable 这个接口，所以这种方式不能序列化Map，也就是不能深拷贝Map。但是HashMap是可以的，因为它实现了 Serializable。 示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void test4() &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(100); list.add(200); Map&lt;String, Object&gt; m1 = new HashMap&lt;String, Object&gt;(); Map&lt;String, Object&gt; m2 = new HashMap&lt;String, Object&gt;(); //放对象 m1.put(\"list\", list); //真正深拷贝 m2 = clone(m1); System.out.println(\"改变前m1:\" + m1); System.out.println(\"改变前m2:\" + m2); list.add(400); System.out.println(\"改变后m1:\" + m1); System.out.println(\"改变后m2:\" + m2); &#125; /** * 对象深度复制(对象必须是实现了Serializable接口) * * @param obj * @return T, 此处传入的T为Map&lt;String, Object&gt;需要更改！！！ * @author Muscleape * @date 2018/8/10 14:39 */ @SuppressWarnings(\"unchecked\") public static &lt;T extends Serializable&gt; T clone(T obj) &#123; T clonedObj = null; try &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(obj); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); clonedObj = (T) ois.readObject(); ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return clonedObj; &#125; 改变前m1:{list=[100, 200]}改变前m2:{list=[100, 200]}改变后m1:{list=[100, 200, 400]}改变后m2:{list=[100, 200]} 补充List 也存在深浅拷贝问题，可以参考HashMap","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}]},{"title":"位运算","slug":"位运算符","date":"2019-02-17T03:14:30.000Z","updated":"2021-03-29T03:01:27.459Z","comments":true,"path":"2019/02/17/位运算符/","link":"","permalink":"http://example.com/2019/02/17/位运算符/","excerpt":"","text":"下面的a和b都是整数类型，则： 含义 Pascal语言 C语言 C#语言 Java 按位与 a and b a &amp; b a &amp; b a &amp; b 按位或 a or b a &#124; b a &#124; b a &#124; b 按位异或 a xor b a ^ b a ^ b a ^ b 按位取反 not a ~a ~a ~a 左移 a shl b a &lt;&lt; b a &lt;&lt; b a &lt;&lt; b 带符号右移 a shr b a &gt;&gt; b a &gt;&gt; b a &gt;&gt; b 无符号右移 a&gt;&gt;&gt; b 运算说明=== 1. and运算 &amp; === and运算通常用于二进制的取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数。 相同位的两个数字都为1，则为1；若有一个不为1，则为0。 00101 11100 （&amp;；或者and） 00100 === 2. or运算 | === or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。 相同位只要一个为1即为1。 00101 11100 （|或者or） 11101 === 3. xor运算 ^ === 异或的符号是^。按位异或运算, 对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作. 操作的结果是如果某位不同则该位为1, 否则该位为0. xor运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即（a xor b) xor b = a。xor运算可以用于简单的加密，比如我想对我MM说1314520，但怕别人知道，于是双方约定拿我的生日19880516作为密钥。1314520 xor 19880516 = 20665500，我就把20665500告诉MM。MM再次计算20665500 xor 19880516的值，得到1314520。 相同位不同则为1，相同则为0。 00101 11100 （^或者xor） 11001 运算结果 x &lt;- x # y y &lt;- x @ y x &lt;- x @ y 执行了第一句后x变成了x # y。那么第二句实质就是y &lt;- x # y @ y，由于#和@互为逆运算，那么此时的y变成了原来的x。第三句中x实际上被赋值为（x # y) @ x，如果#运算具有交换律，那么赋值后x就变成最初的y了。这三句话的结果是，x和y的位置互换了。 加法和减法互为逆运算，并且加法满足交换律。把#换成+，把@换成-，我们可以写出一个不需要临时变量的swap过程（Pascal）。 procedure swap(var a,b:longint); begin a:=a + b; b:=a - b; a:=a - b; end; 好了，刚才不是说xor的逆运算是它本身吗？于是我们就有了一个看起来非常诡异的swap过程： procedure swap(var a,b:longint); begin a:=a xor b; b:=a xor b; a:=a xor b; end; 注意：位运算版本的交换两数不适用于一个数的自我交换。也就是说，如果上述程序的“b”改成“a”的话，其结果是变量a变成零。因此，在使用快速排序时，由于涉及到一个数的自我交换，因此如果要在其中使用位运算版的交换两数的话，应该先判断。具体的时间损耗在此略过。 === 4. not运算 ~ === not运算的定义是把内存中的0和1全部取反。使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用00到$FFFF依次表示的。下面的两个程序（仅语言不同）均返回65435。 var a:word; begin a:=100; a:=not a; writeln(a); end. 12345678#include&lt;stdio.h&gt;int main()&#123; unsigned short a=100; a=~a; printf(\"%d\\n\",a); return 0;&#125; 如果not的对象是有符号的整数，情况就不一样了，稍后我们会在“整数类型的储存”小节中提到。 === 5. shl运算 &lt;&lt; === a shl b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 shl 2 = 400。可以看出，a shl b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。 通常认为a shl 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。 定义一些常量可能会用到shl运算。你可以方便地用1 shl 16 - 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用shl来定义Max_N等常量。 === 6. shr运算 &gt;&gt; === 和shl相似，a shr b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们也经常用shr 1来代替div 2，比如二分查找、堆的插入操作等等。想办法用shr代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60%。 优先级C语言中位运算符之间，按优先级顺序排列为 1 ~ 2 &lt;&lt;、&gt;&gt; 3 &amp; 4 ^ 5 &#124; 6 &amp;=、^=、&#124;=、&lt;&lt;=、&gt;&gt;= 右移运算(&gt;&gt;)右移运算符是将一个二进制数按指定移动的位数向右移动。 移动过程中，正数最高位补0，负数最高位补1，无符号数最高位补0。 补码 在计算机系统中，数值一律用补码来表示和存储，其中最高位表示符号位，1表示负数，0表示正数。 · 正数的补码是原码自身。 · 负数补码是通过原码计算得到，计算过程为：符号位不变，其余位按照原码取反加1 补码计算示例 以计算十进制-100的补码为例，计算过程为： -100的原码： 10000000 00000000 00000000 01100100符号位保持不变，取反：11111111 11111111 11111111 10011011加1后，-100补码为： 11111111 11111111 11111111 10011100 下面右移都是以整数为例，不考虑小数情况。 正数右移 正数右移高位需补0，以100右移4位为例： 操作 二进制 对应十进制 补码 00000000 00000000 00000000 01100100 100 右移4位 00000000 00000000 00000000 00000110 6 源码 00000000 00000000 00000000 00000110 6 最后可得: 100 &gt;&gt; 4 = 6 正数的右移相当于除法，右移几位就除以2的几次方，如100&gt;&gt;4 等效 100/2^4 负数右移 负数右移高位需补1，以-100右移4位为例： 操作 二进制 对应十进制 原码 10000000 00000000 00000000 01100100 -100 转换为补码 11111111 11111111 11111111 10011100 -100 右移4位，高位补1 11111111 11111111 11111111 11111001 保留符号位，按位取反 10000000 00000000 00000000 00000110 加1后转为源码 10000000 00000000 00000000 00000111 -7 最后可得： -100 &gt;&gt; 4 = -7 负数的右移不等于除法，即负数右移不能按除以2的n次方计算（n表示移动位数）。 无符号右移 无符号右移和正数右移相同，都是高位补0，以-100右移4位为例： 操作 二进制 对应十进制 原码 10000000 00000000 00000000 01100100 -100 转换为补码 11111111 11111111 11111111 10011100 -100 右移4位，高位补0 00001111 11111111 11111111 11111001 转为原码 00001111 11111111 11111111 11111001 268435449 最后可得： -100 &gt;&gt;&gt; 4 = 268435449 右移28位后，最高位为0表示正数，所以原码即为补码本身。“&gt;&gt;&gt;”是Java里的无符号右移操作符。 总结 正数的右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。负数的右移，就是补码高位补1,然后按位取反加1即可。 左移运算(&lt;&lt;)运算规则： 按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。 语法格式： 需要移位的数字 &lt;&lt; 移位的次数 例如： 3 &lt;&lt; 2，则是将数字3左移2位 计算过程： 3 &lt;&lt; 2 首先把3转换为二进制数字0000 0011，然后把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位，最后在低位(右侧)的两个空位补零。则得到的最终结果是0000 1100，则转换为十进制是12。 数学意义： 在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/位运算/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"The component for route must be a react component","slug":"react-native-problem2","date":"2019-02-16T03:11:24.000Z","updated":"2021-03-29T03:01:27.449Z","comments":true,"path":"2019/02/16/react-native-problem2/","link":"","permalink":"http://example.com/2019/02/16/react-native-problem2/","excerpt":"","text":"问题描述： 源代码 问题分析：在路由中配置其它组件时必须要在前面先定义。 更改后代码","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/前端/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://example.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/前端/"}]},{"title":"图标库不显示问题","slug":"react-native-problem1","date":"2019-02-15T03:11:18.000Z","updated":"2021-03-29T03:01:27.448Z","comments":true,"path":"2019/02/15/react-native-problem1/","link":"","permalink":"http://example.com/2019/02/15/react-native-problem1/","excerpt":"","text":"问题描述： 在BottomTabNavigator中使用图标库，运行时图标不显示、不报错。 源代码 问题分析：在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的return语句。 12345var func = x =&gt; x * x; // 简写函数 省略returnvar func = (x, y) =&gt; &#123; return x + y; &#125;; //常规编写 明确的返回值 更改后代码","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/前端/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://example.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/前端/"}]},{"title":"InputStream数据读取","slug":"InputStream数据读取","date":"2019-02-14T03:13:53.000Z","updated":"2021-05-14T09:23:27.711Z","comments":true,"path":"2019/02/14/InputStream数据读取/","link":"","permalink":"http://example.com/2019/02/14/InputStream数据读取/","excerpt":"","text":"1int data0 = inputStream.read(); · read() : 从(来源)输入流中(读取的内容)读取数据的下一个字节到(去处)java程序内部中返回值为0到255的int类型的值，返回值为字符的ASCII值(如a就返回97,n就返回110)。 如果没有可用的字节,因为已经到达流的末尾, -1返回的值。运行一次只读一个字节,所以经常与while((len = inputstream.read()) != -1)一起使用 12byte[] buffer=new byte[512];int size = mInputStream.read(buffer); · read(byte[] b)：从输入流中读取一定数量的字节，并将其存储在缓冲区数组b 中。以整数形式返回实际读取的字节数。在输入数据可用、检测到文件末尾或者抛出异常前，此方法一直阻塞。 · 如果 b 的长度为 0，则不读取任何字节并返回 0；否则，尝试读取至少一个字节。如果因为流位于文件末尾而没有可用的字节，则返回值 -1；否则，至少读取一个字节并将其存储在 b *中。 · 将读取的第一个字节存储在元素b[0] 中，下一个存储在 b[1] 中，依次类推。读取的字节数最多等于b 的长度。设 k为实际读取的字节数；这些字节将存储在b[0] 到 b[k-1] 的元素中，不影响 b[k] 到b[b.length-1] 的元素。 1int newcount = inputStream.read(b, off, len); · read(byte[] b, int off, int len)：读取 len字节的数据从输入流到一个字节数组。 · 试图读取多达 len字节,但可能读取到少于len字节。返回实际读取的字节数为整数。 · 第一个字节存储读入元素b[off],下一个b[off+1],等等。读取的字节数是最多等于len。k被读取的字节数,这些字节将存储在元素通过b[off+k-1]b[off]，离开元素通过b[off+len-1]b[off+k]未受影响。 · read(byte[]b)就是相当于read(byte [] b , 0 , b.length).所以两者差不多，性质一样。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}]},{"title":"android模拟器与chrome进行Remote JS Debugging连接不上","slug":"Remote-JS-Debugging","date":"2019-01-24T06:59:09.000Z","updated":"2021-03-29T03:01:27.433Z","comments":true,"path":"2019/01/24/Remote-JS-Debugging/","link":"","permalink":"http://example.com/2019/01/24/Remote-JS-Debugging/","excerpt":"","text":"现象在Android模拟器上进行 Debug JS Remotely时，Chrome浏览器会自动打开http://10.0.2.2:8081/debugger-ui ，但此网址无法访问。 解决方法 在模拟器上Ctrl + M 进入开发者菜单 Dev settings &gt; Debug server host &amp; port for device 设置 localhost:8081 重新运行 react-native run-android 真机调试在iOS上打开RCTWebSocketExecutor.m文件，将“localhost”改为你的电脑IP，然后在Developer Menu下单机“Debug JS Remotely”启动JS远程调试。 在Android上默认情况下不用进行设置就可以进行调试，当报错时进行以下方法。 方法一：在Android5.0以上设备，将手机通过usb连接到电脑上，然后输入以下adb命令来设置端口转发 1adb reverse tcp:8081 tcp:8081 方法二：通过在“Developer Menu”下的“Dev Settings”中设置你的电脑ip来进行调试（保证他们在同一个路由器下）","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/前端/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://example.com/tags/react-native/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/前端/"}]},{"title":"Android Uri和Path","slug":"Android-Uri和Path","date":"2019-01-19T06:09:23.000Z","updated":"2021-05-14T09:03:28.704Z","comments":true,"path":"2019/01/19/Android-Uri和Path/","link":"","permalink":"http://example.com/2019/01/19/Android-Uri和Path/","excerpt":"","text":"起因拍照后要保存图片，我们需要指定一个存储图片路径的Uri。此时需要将file path转换为Uri。 打开相册，选取本地的二维码图片识别，此时需要将Uri转Path，以获取图片路径。 Android Uri to PathAndroid在4.4之后的版本(包括4.4)中，从相册中选取图片返回Uri进行了改动。所以我们无法通过该Uri来取得文件路径，从而解码图片，将其显示出来。 在4.4之后的，包括4.4的版本，返回的Uri有可能是以下的一种: content://com.android.providers.media.documents/document/image:642 content://com.android.providers.downloads.documents/document/ content://media/external/images/media/ 不能直接通过前两种Uri直接获取到对应的表，所以需要”翻译一下”: 1234567891011121314151617181920212223242526272829303132333435363738private void handleImageOnKitKat(Intent data) &#123; String imagePath = null; Uri uri = data.getData(); if (DocumentsContract.isDocumentUri(this, uri)) &#123; String docId = DocumentsContract.getDocumentId(uri); if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) &#123; //Log.d(TAG, uri.toString()); String id = docId.split(\":\")[1]; String selection = MediaStore.Images.Media._ID + \"=\" + id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection); &#125; else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) &#123; //Log.d(TAG, uri.toString()); Uri contentUri = ContentUris.withAppendedId( Uri.parse(\"content://downloads/public_downloads\"), Long.valueOf(docId)); imagePath = getImagePath(contentUri, null); &#125; &#125; else if (\"content\".equalsIgnoreCase(uri.getScheme())) &#123; //Log.d(TAG, \"content: \" + uri.toString()); imagePath = getImagePath(uri, null); &#125; &#125; private String getImagePath(Uri uri, String selection) &#123; String path = null; Cursor cursor = getContentResolver().query(uri, null, selection, null, null); if (cursor != null) &#123; if (cursor.moveToFirst()) &#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; Android Path To Uri1.Uri.parse(path) 2.Uri.fromFile(new File(path)) File Path To Media Uri 12345678910111213141516public static Uri getMediaUriFromPath(Context context, String path) &#123; Uri mediaUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; Cursor cursor = context.getContentResolver().query(mediaUri, null, MediaStore.Images.Media.DISPLAY_NAME + \"= ?\", new String[] &#123;path.substring(path.lastIndexOf(\"/\") + 1)&#125;, null); Uri uri = null; if(cursor.moveToFirst()) &#123; uri = ContentUris.withAppendedId(mediaUri, cursor.getLong(cursor.getColumnIndex(MediaStore.Images.Media._ID))); &#125; cursor.close(); return uri; &#125; 参考资料： https://www.jianshu.com/p/f9a63fcc0b91 https://www.jianshu.com/p/33bc363290e9","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"Windows生成公钥和私钥","slug":"Windows生成公钥和私钥","date":"2019-01-10T03:00:00.000Z","updated":"2021-03-29T03:12:19.771Z","comments":true,"path":"2019/01/10/Windows生成公钥和私钥/","link":"","permalink":"http://example.com/2019/01/10/Windows生成公钥和私钥/","excerpt":"","text":"Windows生成公钥和私钥 1.进入C:\\Users\\RH.ssh 目录 2.ssh-keygen -t rsa 3.Enter 4.Enter 5.Enter 复制id_rsa.pub里的内容","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"感知机","slug":"感知机","date":"2018-12-14T11:54:53.000Z","updated":"2021-03-29T03:01:27.461Z","comments":true,"path":"2018/12/14/感知机/","link":"","permalink":"http://example.com/2018/12/14/感知机/","excerpt":"","text":"感知机(percetron)算法是由美国学者Frank Roseenblatt在1957年提出，是神经网络(深度学习)起源的算法。 感知机是什么 感知机接受多个信号，输出一个信号。其中信号取值0/1，代表“传递/不传递”。 如下图，x1、x2是输入信号，y是输出信号，w1、w2是权重，圈是神经元。当输入信号传入神经元后，神经元会计算信号的总和，当总和超过阈值θ时输出1。 感知机运行原理通过数学方式表达如下，感知机多个输入信号都有各自的权重，权重越大，对应该权重的信号重要性越高。 将公式进行转化如下，其中b为偏置 感知机的实现 通过感知机的原理，我们能模拟简单的逻辑电路。 与门仅在两个输入均为1时输出1，其他的时候输出0。 与非门仅在两个输入同时为1时为0，其他的时候输出1。 或门在两个输入相同时为1，不同时为0。 根据真值表中的四组值，我们能通过作图寻找满足公式的直线。如图阴影部分为小于0的部分。 这种能够满足感知机的直线有很多条，我们只选其中一条实现。 123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as np X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])def AND(x): w = ([0.5, 0.5]) b = -0.7 tmp = np.sum(w*x) + b if tmp &gt; 0: return 1; else: return 0; def NAND(x): w = ([-0.5, -0.5]) b = 0.7 tmp = np.sum(w*x) + b if tmp &gt; 0: return 1; else: return 0;def OR(x): w = ([0.5, 0.5]) b = -0.2 tmp = np.sum(w*x) + b if tmp &gt; 0: return 1; else: return 0; print(\"AND:\")for i in [0, 1, 2, 3]: print(AND(X[i]))print(\"NAND:\")for i in [0, 1, 2, 3]: print(NAND(X[i]))print(\"OR:\")for i in [0, 1, 2, 3]: print(OR(X[i])) 多层感知机 根据公式我们了解感知机模板是线性关系的，只用改变w(权重)和b(偏置)就能实现各种线性关系。但现实中有许多情况是非线性的，比如异或门。异或门在两个输入相同时为1，不同时为0。 在现实中，我们可以通过与门、与非门和或门可以组合成异或门 12345678def XOR(x): s = np.array([NAND(x), OR(x)]) y = AND(s) return yprint(\"XOR:\")for i in [0, 1, 2, 3]: print(XOR(X[i])) 这样异或门的实现就完成，这种实现称为2层感知机， 叠加了多成的感知机也成为多层感知机。通过叠加的方式可以使感知机的线性关系转换成非线性关系。多层感知机在理论上可以表示计算机。","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/深度学习/"},{"name":"感知机","slug":"感知机","permalink":"http://example.com/tags/感知机/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}]},{"title":"Python入门","slug":"Python入门","date":"2018-12-11T11:54:53.000Z","updated":"2021-03-29T03:01:27.436Z","comments":true,"path":"2018/12/11/Python入门/","link":"","permalink":"http://example.com/2018/12/11/Python入门/","excerpt":"","text":"Python是什么 Python是一个简单、易读、易记的编程语言，而且而且是开源的，可以免费地自由使用。Python可以用类似英语的语法编写程序，编译起来也不费力，因此我们可以很轻松的使用Python。 此外，使用Python不仅可以写出可读性高的代码，还可以写出性能高的代码，在需要处理大规模数据或者要求快速强硬的情况下，使用Python可以稳妥的完成。 再者，在科学领域，特别是机器学习、数据科学领域，Python也被大量使用。Python除了高性能之外，凭借NumPy、SciPy等优秀的数值计算、统计分析库，在数据科学领域再有不可动摇的地位。Caffe、TensorFlow、Chainer、Theano等深度学习框架也都提供了Python接口，因此，学习Python对使用深度学习框架大有益处。 综上，Python是最适合数据科学领域的编程语言，也是初学者学习深度学习最合适的工具。 Python安装 Python有Python2.x和Python3.x两个版本，两个版本都被大量的使用但不相兼容，安装时应当注意。 为了有效的促进深度学习的实现，需要安装并学习NumPy库和Matplotlib库的使用。NumPy是用于数值计算的库，提供了很多高级的数学算法和便利的数组(矩阵)操作方法。Matplotlib是用来画图的库，能将实验结果可视化。 Python的安装方法有很多种，这里推荐Anaconda Python3.x发行版。Anaconda是一个侧重于数据分析的发行版，其中集成NumPy，Matplotlib等有助于数据分析的库。 Python解释器 完成Python的安装后，要确认Python的版本。打开cmd，输入Python –version。 python --version Python 3.7.0 确认安装版本后，启动Python解释器。输入python。 python Python 3.7.0 (default, Jun 28 2018, 08:04:48) [MSC v.1912 64 bit (AMD64)] :: Anaconda, Inc. on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; Python解释器也被称为“对话模式”，用户能够以Python对话的方式进行编程。以下借助对话介绍Python基本语法。 1. 算数计算 *表示乘法，/ 表示除法，** 表示乘方，注意整数除以整数，在Python2.x中为整数，Python3.x中为浮点数。 1 + 2 31 - 2 -14 * 5 207 / 5 1.43 ** 2 9 2. 数据类型 数据类型表示数据的性质，有整数、小数、字符串等类型，type()可以用来查看数据类型。 type(10) type(2.718) type(“hello”) 3. 变量 Python是属于“动态类型语言”的编程语言，所谓动态，是指变量的类型是根据情况自动决定的。“#”为注释 x = 10 # 初始化print(x) # 输出x 10x = 100 # 赋值print(x) 100y = 3.14x y 314.0type(x y) 4. 列表 列表(数组)用于汇总数据，可以通过索引(下标)访问元素。 a = [1, 2, 3, 4, 5] # 生成列表print(a) # 输出列表内容 [1, 2, 3, 4, 5]len(a) # 获取列表长度 5a[0] # 访问第一个元素的值 1a[4] 5a[4] = 99 # 赋值print(a) [1, 2, 3, 4, 99]列表还提供了切片(slicing)标记法，切片不仅可以访问某个值，还可以访问子列表。 print(a) [1, 2, 3, 4, 99]a[0:2] # 获取索引为0到2（不包括2！）的元素 [1, 2]a[1:] # 获取从索引为1的元素到最后一个元素 [2, 3, 4, 99]a[:3] # 获取从第一个元素到索引为3（不包括3！）的元素 [1, 2, 3]a[:-1] # 获取从第一个元素到最后一个元素的前一个元素之间的元素 [1, 2, 3, 4]a[:-2] # 获取从第一个元素到最后一个元素的前二个元素之间的元素 [1, 2, 3] 5. 字典 列表以索引存储数据，字典以键值对形式存储数据。 me = {‘height’:180} # 生成字典me[‘height’] # 访问字典 180me[‘weight’] = 70 # 添加新字典print(me) {‘height’: 180, ‘weight’: 70} 6. 布尔型 bool型取True或False中的一个值，针对bool型运算符包括and、or、not。 hungry = True # 饿了sleepy = False # 困了type(hungry) not hungry Falsehungry and sleepy # 饿并且困 Falsehungry or sleepy # 饿或者困 True 7. if语句 根据不同的条件选择不同的处理分支可使用if/else语句。使用时注意缩进，推荐使用4个空白字符。 hungry = Trueif hungry: … print(“I’m hungry”) … I’m hungryhungry = Falseif hungry: … print(“I’m hungry”) … else: … print(“I’m not hungry”) … print(“I’m sleepy”) … I’m not hungry I’m sleepy 8. for语句 进行循环处理可使用for语句 for i in [1, 2, 3]: … print(i) … 1 2 3 9. 函数 将一连串的处理定义成函数(function)。字符串拼接可以用+。 def hello(): … print(“hello world!”) …hello() hello world! def hello(object): … print(“Hello “ + object + “!”) …hello(“cat”) Hello cat! 10. 类 之前int和str为系统内置的数据类型，我们可以自己定义新的类，并定义方法与属性。 class 类名： def __init__(self, 参数, …): # 构造函数 ... def 方法名1(self, 参数, …): # 方法1 ... def 方法名2(self, 参数, …): # 方法2 ... __init__为初始化方法，也成为构造方法，此外，Python第一个参数需要以self表明自身。 class Man: def __init__(self, name): self.name = name print(&quot;Initialized!&quot;) def hello(self): print(&quot;Hello &quot; + self.name + &quot;!&quot;) def goodbye(self): print(&quot;Good-bye &quot; +self.name + &quot;!&quot;) m = Man(&quot;David&quot;) m.hello() m.goodbye() Initialized! Hello David! Good-bye David! Python脚本文件 Python解释器能够以对话模式执行程序，非常便于进行简单的实验。但是进行一连串的处理并不方便，这时可将Python程序保存为文件，运行这个文件即可。这就是Python脚本文件。 打开文本编辑器，新建一个hungry.py文件，包含一条一句语句 print(&quot;I&apos;m hungry&quot;) 打开cmd终端，移动到文件目录下，执行python hungry.py命令 python hungry.py I&apos;m hungry NumPy NumPy是Python的外部库，需要导入方可使用。 import numpy as np # 将numpy作为np导入 深度学习中将经常用到NumPy数组类的操作。 x = np.array([1.0, 2.0, 3.0])print(x) [1. 2. 3.]type(x) NumPy数组之间可以进行算数运算。 x = np.array([1.0, 2.0, 3.0])y = np.array([2.0, 4.0, 6.0])x + y # 对应元素加法 array([3., 6., 9.])x - y array([-1., -2., -3.])x * y # 对应元素乘法 array([ 2., 8., 18.])x / y array([0.5, 0.5, 0.5])NumPy可以实现多维数组，并执行多维数组之间的操作 A = np.array([[1, 2], [3, 4]])print(A) [[1 2] [3 4]]A.shape # 查看数组形状 (2, 2)A.dtype # 查看数组数据类型 dtype(‘int32’)B = np.array([[3, 0], [0, 6]])A + B # 对应元素加法 array([[ 4, 2], [ 3, 10]])A * B # 对应元素乘法 array([[ 3, 0], [ 0, 24]])在NumPy中，形状不同的数组之间也可以进行运算，称之为广播。 A = np.array([[1, 2], [3, 4]])A 10 array([[10, 20], [30, 40]])B = np.array([10, 20])A B array([[10, 40], [30, 80]])访问NumPy数组的元素需要通过索引、for循环或者标记法。 X = np.array([[51, 55], [14, 19], [0, 4]])print(X) [[51 55] [14 19] [ 0 4]]X[0] array([51, 55])X[0][1] 55 for row in X: … print(row) … [51 55] [14 19] [0 4] X &gt; 15 array([[ True, True], [False, True], [False, False]])X[X&gt;15] array([51, 55, 19]) Matplotlib Matplotlib是Python的外部库，可以轻松绘制图形和实现数据的可视化。 使用matplotlib的pyplot绘制sin函数曲线 import numpy as np import matplotlib.pyplot as plt # 生成数据 x = np.arange(0, 6, 0.1) # 以0.1为单位，生成0到6的数据 y = np.sin(x); # 绘制图形 plt.plot(x, y); plt.show() 通过pyplot实现追加cos函数、添加标题、x轴签名等功能。 import numpy as np import matplotlib.pyplot as plt # 生成数据 x = np.arange(0, 6, 0.1) # 以0.1为单位，生成0到6的数据 y1 = np.sin(x) y2 = np.cos(x) # 绘制图形 plt.plot(x, y1, label=&quot;sin&quot;) plt.plot(x, y2, linestyle=&quot;--&quot;, label=&quot;cos&quot;) # 用虚线绘制 plt.xlabel(&quot;x&quot;) # x轴标签 plt.ylabel(&quot;y&quot;) # y轴标签 plt.title(&quot;sin &amp; cos&quot;) # 标题 plt.legend() plt.show() pyplot中还提供了imshow()用于显示图像，image中imread()用于读入图像。 import matplotlib.pyplot as plt from matplotlib.image import imread img = imread(&quot;../img/3.jpg&quot;); # 读入图像(设置合适的路径！) plt.imshow(img) plt.show()","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/深度学习/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}]},{"title":"HashMap和Bundle","slug":"HashMap-Bundle","date":"2018-12-01T07:03:44.000Z","updated":"2021-05-14T09:14:21.520Z","comments":true,"path":"2018/12/01/HashMap-Bundle/","link":"","permalink":"http://example.com/2018/12/01/HashMap-Bundle/","excerpt":"","text":"HashMap(JAVA)HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 HashMap主要是用Entry数组来存储数据的，我们都知道它会对key进行哈希运算，哈系运算会有重复的哈希值，对于哈希值的冲突，HashMap采用链表来解决的。 HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 HashMap的API void clear() Object clone() boolean containsKey(Object key) boolean containsValue(Object value) Set&lt;Entry&lt;K, V&gt;&gt; entrySet() V get(Object key) boolean isEmpty() Set keySet() V put(K key, V value) void putAll(Map&lt;? extends K, ? extends V&gt; map) V remove(Object key) int size() Collection values() 1234567891011121314151617181920212223242526272829303132private static void testHashMapAPIs() &#123; // 初始化随机种子 Random r = new Random(); // 新建HashMap HashMap map = new HashMap(); // 添加操作 map.put(\"one\", r.nextInt(10)); map.put(\"two\", r.nextInt(10)); map.put(\"three\", r.nextInt(10)); // 打印出map System.out.println(\"map:\"+map ); // 通过Iterator遍历key-value Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.println(\"next : \"+ entry.getKey() +\" - \"+entry.getValue()); &#125; // HashMap的键值对个数 System.out.println(\"size:\"+map.size()); // containsKey(Object key) :是否包含键key System.out.println(\"contains key two : \"+map.containsKey(\"two\")); System.out.println(\"contains key five : \"+map.containsKey(\"five\")); // containsValue(Object value) :是否包含值value System.out.println(\"contains value 0 : \"+map.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 map.remove(\"three\"); System.out.println(\"map:\"+map ); // clear() ： 清空HashMap map.clear(); // isEmpty() : HashMap是否为空 System.out.println((map.isEmpty()?\"map is empty\":\"map is not empty\") );&#125; Bundle（Android）一种存放字符串和Parcelable类型数据的map类型的容器类，通过存放数据键（key）获取对应的各种类型的值（value），而且必须通过键（key）获取。 代码示例 12345678910//TestBundle.javaBundle bundle = new Bundle();//创建一个句柄bundle.putString(\"name\", nameinfo);//将nameinfo填充入句柄Intent mIntent = new Intent(TestBundle.this,TestBundle_getvalue.class);mIntent.putExtras(bundle);startActivity(mIntent);//TestBundle_getvalue.javaBundle bundle = getIntent().getExtras();//获取一个句柄String nameString=bundle.get(\"name\");//通过key为“name”来获取value即 nameString. Android为什么要设计出Bundle而不是直接使用HashMap来进行数据传递？ Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。 另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"},{"name":"Bundle","slug":"Bundle","permalink":"http://example.com/tags/Bundle/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"HTTP、Socket、WebSocket、WebService","slug":"http-socket-websocket-webservice","date":"2018-11-28T07:49:28.000Z","updated":"2021-05-14T09:15:25.727Z","comments":true,"path":"2018/11/28/http-socket-websocket-webservice/","link":"","permalink":"http://example.com/2018/11/28/http-socket-websocket-webservice/","excerpt":"","text":"网络分层 图片转载自：https://blog.csdn.net/skyroben/article/details/77073834 ，可前往查看原图。 协议IP 协议对应于网络层，同样解决数据在网络中的传输。 TCP 协议传输控制协议，对应于传输层。是一种面向连接的、可靠的、基于字节流的传输层通信协议，主要解决数据在网络中的传输。使用三次握手协议建立连接，进行数据重发，保证了连接的可靠性。理论上，TCP 连接一旦建立，在通讯双方中的任何一方主动断开连接之前 TCP 连接会一直保持下去。 UDP协议是一个简单的面向数据报的传输层协议。在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发。 TCP/IP 协议即互联网协议，是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。为了突出 TCP 与 IP 这两个协议的重要性，所以就用 TCP/IP 来表示 TCP/IP 协议族了。 HTTP 协议超文本传输协议，对应于应用层，用于如何封装数据。 HTTP为短连接：客户端发送请求都需要服务器端回送响应.请求结束后，主动释放链接，因此为短连接。 补充 我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。 TCP 与 UDP 的区别 TCP 用于在传输层有必要实现可靠传输的情况。由于它是面向有链接并具备顺序控制、重发控制等机制的，所以他可以为应用提供可靠的传输。 而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。 我们举一个通过 IP 电话进行通话的例子。如果使用 TCP，数据在传送途中如果丢失会被重发，但这样无法流畅的传输通话人的声音，会导致无法进行正常交流。而采用 UDP，他不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也支持会影响某一小部分的通话。此外，在多播与广播通信、视频中也是用 UDP 而不是 TCP。 什么是Socket？Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。” CSDN上有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 Socket连接为长连接：通常情况下Socket 连接就是 TCP 连接（Socket当然也可以进行UDP无连接通讯），因此 Socket 连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。在实际应用中，由于网络节点过多，在传输过程中，会被节点断开连接，因此要通过轮询高速网络，保证该节点处于活跃状态。 若双方是 Socket 连接，可以由服务器直接向客户端发送数据。 若双方是 HTTP 连接，则服务器需要等客户端发送请求后，才能将数据回传给客户端。 什么是 WebSocket？WebSocket是HTML5规范提出的一种在单个TCP连接上进行全双工通信的应用层协议。它和HTTP一样都是基于TCP的。 不同的是HTTP是单向的、短连接，而WebSocket是双向的、长连接。 在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行全双工通信。但是建立之后，在真正传输时候是不需要HTTP协议的。 图片来源: https://img-blog.csdn.net/20170626140009906 ，若图片无法加载请查看原图 什么是 WebService？WebService是一种跨编程语言和跨操作系统平台的远程调用技术。 所谓跨编程语言和跨操作平台，就是说服务端程序采用java编写，客户端程序则可以采用其他编程语言编写，反之亦然！跨操作系统平台则是指服务端程序和客户端程序可以在不同的操作系统上运行。 从表面上看，WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过Web来调用这个应用程序。我们把调用这个WebService的应用程序叫做客户端，而把提供这个WebService的应用程序叫做服务端 WebService通过HTTP协议发送请求和接收结果的，但相比HTTP只传输字符串,它发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。 SOAP协议 = HTTP协议 + XML数据格式 参考文章 http://lib.csdn.net/article/computernetworks/20534 https://www.jianshu.com/p/a18a5ba78fad https://www.jianshu.com/p/219eb040479b https://blog.csdn.net/SL_ideas/article/details/73648378 https://blog.csdn.net/chaoshenzhaoxichao/article/details/79785318 https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F https://www.jianshu.com/p/49d7997ad3b7","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"协议","slug":"协议","permalink":"http://example.com/tags/协议/"},{"name":"通讯","slug":"通讯","permalink":"http://example.com/tags/通讯/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"线程池","slug":"thread-pool","date":"2018-11-28T05:20:25.000Z","updated":"2021-05-14T09:08:31.902Z","comments":true,"path":"2018/11/28/thread-pool/","link":"","permalink":"http://example.com/2018/11/28/thread-pool/","excerpt":"","text":"说明标记以下比较重要的类： ExecutorService 真正的线程池接口 ScheduledExecutorService 能和Timer/TimerTask类似，解决那些需要任务重复执行的问题 ThreadPoolExecutor ExecutorService的默认实现 ScheduledThreadPoolExecutor 继承ThreadPoolExecutor，实现ScheduledExecutorService接口，周期性任务调度的类实现 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程(例如：不能直接new Thread(){}.start();))。 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 线程池不允许使用Executors 去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗费的风险。 说明： Executors各个方法的弊端： 1） newFixedThreadPool和newSingleThreadExecutor: 主要问题是堆积的请求处理队列可能会耗费很大的内存，甚至OOM。 2） newCachedThreadPool和newScheduledThreadPool 主要问题是线程数最大是Integer.MAX_VALUE,可能会创建数量非常多的线程，甚至OOM 推荐使用方法 单线程示例123456789101112131415161718//线程池命名ThreadFactory namedThreadFactory = new ThreadFactoryBuilder() .setNameFormat(\"demo-pool-%d\") .build();//创建线程池 ExecutorService singleThreadPool = new ThreadPoolExecutor( 1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy() ); singleThreadPool.execute(() -&gt; System.out.println(Thread.currentThread().getName())); singleThreadPool.shutdown(); 周期性线程示例123456789101112131415161718192021222324252627282930//创建定时任务线程ScheduledExecutorService schedualExec = new ScheduledThreadPoolExecutor(1); ScheduledFuture downData = schedualExec.scheduleWithFixedDelay(task, 1000, 3000, TimeUnit. MILLISECONDS ); Runnable task = () -&gt; &#123; System.out.println(\"上传1:\" + new Date()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; public void close() &#123; if (schedualExec != null &amp;&amp; !schedualExec.isShutdown()) &#123; schedualExec.schedule(new Runnable() &#123; @Override public void run() &#123; if (downData != null) &#123; downData.cancel(true); &#125; &#125; &#125;, 1, TimeUnit.SECONDS); schedualExec.shutdownNow(); &#125; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"线程池","slug":"线程池","permalink":"http://example.com/tags/线程池/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://example.com/categories/后端/"}]},{"title":"定时任务和倒计时","slug":"timed-task","date":"2018-11-27T05:24:44.000Z","updated":"2021-05-14T09:08:50.029Z","comments":true,"path":"2018/11/27/timed-task/","link":"","permalink":"http://example.com/2018/11/27/timed-task/","excerpt":"","text":"Java 基本的定时任务 总结方法有三种： 创建一个thread，然后让它在while循环里一直运行着，通过sleep方法来达到定时任务的效果； 12345678910111213141516171819202122package com.rh.demo;public class JavaTimerTest1 &#123; public static void main(String[] args) &#123; final long timeInterval = 1000; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; while (true) &#123; System.out.println(\"Hello\"); try &#123; Thread.sleep(timeInterval); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread thread = new Thread(runnable); thread.start(); &#125;&#125; 用Timer和TimerTask 与第一种方法相比有如下好处： 当启动和去取消任务时可以控制 第一次执行任务时可以指定你想要的delay时间 1234567891011121314151617181920package com.rh.demo;import java.util.Timer;import java.util.TimerTask;public class JavaTimerTest2 &#123; public static void main(String[] args) &#123; TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; System.out.println(\"Hello\"); &#125; &#125;; Timer timer = new Timer(); long delay = 0; long intevalPeriod = 1 * 1000; timer.scheduleAtFixedRate(timerTask,delay,intevalPeriod); &#125;&#125; 用ScheduledExecutorService 做为并发工具类被引进的，这是最理想的定时任务实现方式，相比于上两个方法，它有以下好处： 相比于Timer的单线程，它是通过线程池的方式来执行任务的 可以很灵活的去设定第一次执行任务delay时间 提供了良好的约定，以便设定执行的时间间隔 1234567891011121314151617181920package com.rh.demo;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class JavaTimerTest3 &#123; public static void main(String[] args) &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Hello\"); &#125; &#125;; //手动创建线程池，效果会更好哦，不推荐使用以下创建线程池方法,详情见博客中‘线程池’一文 ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); service.scheduleAtFixedRate(runnable, 0, 1, TimeUnit.SECONDS); &#125;&#125; 方法说明： schedule(commod,delay,unit) ，这个方法是说系统启动后，需要等待多久执行，delay是等待时间。只执行一次，没有周期性。 scheduledThreadPool.scheduleAtFixedRate(new TaskTest(“执行调度任务3”),0, 1, TimeUnit.SECONDS); //这个就是每隔1秒，开启一个新线程，不管上一次是否执行完 scheduledThreadPool.scheduleWithFixedDelay(new TaskTest(“第四个”),0, 3, TimeUnit.SECONDS); //这个就是上一个任务执行完，3秒后开启一个新线程 Android中独有的定时任务 Handler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * handler定时器使用postDelyed实现 * * @author Smalt * */ public class HanderDemoActivity extends Activity &#123; TextView tvShow; private int i = 0; private int TIME = 1000; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); tvShow = (TextView) findViewById(R.id.tv_show); handler.postDelayed(runnable, TIME); //每隔1s执行 //handler.removeCallbacks(runnable); //关闭计时器 &#125; Handler handler = new Handler(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; // handler自带方法实现定时器 try &#123; handler.postDelayed(this, TIME); tvShow.setText(Integer.toString(i++)); System.out.println(\"do...\"); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(\"exception...\"); &#125; &#125; &#125;; &#125; AlarmManager 123456789101112131415161718192021222324//每隔5s运行一次HorizonServicepublic class HorizonService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Log.d(\"TAG\", \"打印时间: \" + new Date().toString()); &#125; &#125;).start(); AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE); int five = 5000; // 这是5s long triggerAtTime = SystemClock.elapsedRealtime() + five; Intent i = new Intent(this, HorizonService.class); PendingIntent pi = PendingIntent.getBroadcast(this, 0, i, 0); manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); return super.onStartCommand(intent, flags, startId); &#125;&#125; 倒计时 简易方式实现 12345678910111213141516171819202122232425262728import java.util.*; import java.util.concurrent.*; public class CountDown &#123; private int limitSec; public CountDown(int limitSec) throws InterruptedException&#123; this.limitSec = limitSec; System.out.println(\"Count from \"+limitSec); while(limitSec &gt; 0)&#123; System.out.println(\"remians \"+ --limitSec +\" s\"); TimeUnit.SECONDS.sleep(1); &#125; System.out.println(\"Time is out\"); &#125; &#125; 使用ScheduleExecutor实现 12345678910111213141516171819202122232425262728293031323334353637 import java.util.concurrent.*; public class CountDown1 &#123; private int curSec; //记录倒计时当下时间 public CountDown1(int limitSec) throws InterruptedException&#123; this.curSec = limitSec; System.out.println(\"count down form \"+limitSec); //手动创建线程池，效果会更好哦，不推荐使用以下创建线程池方法 ScheduledExecutorService exec = Executors.newScheduledThreadPool(1); exec.scheduleAtFixedRate(new Task(),0,1,TimeUnit.SECONDS); TimeUnit.SECONDS.sleep(limitSec);//sleeping for limitSec seconds exec.shutdownNow(); System.out.println(\"Time out！\"); &#125; private class Task implements Runnable&#123; @Override public void run()&#123; System.out.println(\"Time remains \"+ --curSec +\" s\"); &#125; &#125; &#125; 使用java.util.Timer实现 1234567891011121314151617181920212223242526272829303132333435import java.util.*; import java.util.concurrent.TimeUnit; public class CountDown2 &#123; private int curSec; public CountDown2(int limitSec) throws InterruptedException&#123; this.curSec = limitSec; System.out.println(\"count down from \"+limitSec+\" s \"); Timer timer = new Timer(); timer.schedule(new TimerTask()&#123; public void run()&#123; System.out.println(\"Time remians \"+ --curSec +\" s\"); &#125; &#125;,0,1000); TimeUnit.SECONDS.sleep(limitSec);//sleeping for limitSec seconds timer.cancel(); System.out.println(\"Time is out!\"); &#125; &#125; Android特有 12345678910new CountDownTimer(10000, 1000) &#123; @Override public void onTick(long millisUntilFinished) &#123; //textview.setText(\"倒计时 \"+(millisUntilFinished / 1000) + \"秒\"); &#125; @Override public void onFinish() &#123; &#125;&#125;.start();","categories":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"keywords":[{"name":"移动端","slug":"移动端","permalink":"http://example.com/categories/移动端/"}]},{"title":"使用hexo搭建个人博客","slug":"hexo-blog-build","date":"2018-11-23T06:35:25.000Z","updated":"2021-03-29T03:01:27.443Z","comments":true,"path":"2018/11/23/hexo-blog-build/","link":"","permalink":"http://example.com/2018/11/23/hexo-blog-build/","excerpt":"","text":"一、安装Node.js和配置好环境 Node.js Git 二、使用 npm 即可完成 Hexo 的安装。1$ npm install hexo-cli -g 三、快速建站初始化blog文件夹，生成相应文件（文件夹名称自定义 12$ hexo init blog$ cd blog 启动server（启动成功后在浏览器输入http://localhost:4000 进行预览） 1$ hexo server More info: Server 创建一个博客文件，名称自定义（source\\_posts\\*.md） 1$ hexo new \"Hello Hexo\" More info: Writing 生成静态网页文件 1$ hexo generate More info: Generating 推送到服务器 1$ hexo deploy More info: Deployment","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]},{"title":"使用Jekyll + GitHub Pages搭建个人博客","slug":"2018-11-22-jekyll-blog-build","date":"2018-11-21T16:00:00.000Z","updated":"2021-03-29T03:01:27.418Z","comments":true,"path":"2018/11/22/2018-11-22-jekyll-blog-build/","link":"","permalink":"http://example.com/2018/11/22/2018-11-22-jekyll-blog-build/","excerpt":"","text":"前言一直就想搭建一个属于自己的博客网站，但是一直拖着没有执行，在一次偶然的机会看到了鸿洋大神的 如何利用github打造博客专属域名，就心血来潮，马上自己动手做了一个，耗时了近一个星期，终于差不多完成了，特意记录下来，供他人参考。 目录 关于Jekyll 关于GitHub Pages 本地环境搭建 安装Ruby 获取博客模板 安装Bundler 创建自己的GitHub Pages 修改模板，上传至服务器 安装异常问题处理 编写文章 参考资源 关于Jekyll Jekyll 是一个免费的生成静态网页的工具，不需要数据库支持。它有一个模版目录，其中包含原始文本格式的文档，通过 Markdown （或者 Textile） 以及 Liquid 转化成一个完整的可发布的静态网站，可以配合第三方服务例如： Disqus（评论）、多说(评论) 以及分享 等等扩展功能，Jekyll 可以直接部署在 Github（国外） 或 Coding（国内） 上，可以绑定自己的域名。Jekyll中文文档、Jekyll英文文档、。 关于GitHub Pages 官方说法是Websites for you and your projects.是一个免费的静态网站托管平台，由github提供，它具有以下特点： GitHub Pages 有 300M 免费空间，资料自己管理，保存可靠； 学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多； 顺便看看 GitHub 工作原理，最好的团队协作流程； GitHub 是趋势； 可以自定义域名 本地环境搭建如果你只是想使用本主题，而不想搭建本地环境，那么可以直接跳过这部分，不搭建本地环境则不能实现本地预览，以下安装操作都是在Windows系统环境下进行。 安装Rubyjekyll本身基于Ruby开发，因此，想要在本地构建一个测试环境需要具有Ruby的开发和运行环境。在windows下，可以使用Rubyinstaller安装（选择带有DEVKIT的安装包），Windows下只需要保持默认状态一路下一步就可以了。 获取博客模板$ git clone https://github.com/JasonRH/Blog-Jekyll.git 安装Bundler建议使用来安装和运行Jekyll。 进入仓库中，直接使用下面命令即可： $ gem install bundler $ bundle install 命令会根据当前目录下的Gemfile（当无法下载时可将source源修改），安装所需要的所有软件。这一步所安装的东西，可以说跟github本身的环境是完全一致的，所以可以确保本地如果没有错误，上传后也不会有错误。而且可以在将来使用下面命令，随时更新环境，十分方便 $ bundle update 使用下面命令，启动转化和本地服务；（每次重新clone下仓库后都需要update） $ bundle exec jekyll server 在浏览器里输入： http://localhost:4000，就可以看到博客效果了。 创建自己的GitHub Pages在你的github里创建一个username.github.io的仓库，username指的是你的github的用户名。 修改模板，上传至服务器将获取的模板复制，放到你自己的仓库中。 在仓库中进行以下操作： 1.把 _posts/ 目录下的文章都去掉。 2.修改 _config.yml 文件里面的内容为你自己的。 3.本地预览: 进入仓库 $ bundle update，然后在浏览器输入：http://localhost:4000 4.确认修改完成后直接push到服务器即可。 然后你在浏览器里输入 username.github.io ，就可以访问你自己的博客了。 安装异常问题处理 解决方案： 在ruby的安装目录下找到engine.rb文件，目录格式如C:\\Ruby25-x64\\lib\\ruby\\gems\\2.5.0\\gems\\sass-3.7.2\\lib\\sass在文件中添加一行Encoding.default_external = Encoding.find(‘utf-8’)`在require语句结束处，如： 1234require &apos;sass/media&apos;require &apos;sass/supports&apos;module Sass Encoding.default_external = Encoding.find(&apos;utf-8&apos;) 目录结构 Jekyll 的核心其实是一个文本转换引擎。它的概念其实就是： 你用你最喜欢的标记语言来写文章，可以是 Markdown，也可以是 Textile,或者就是简单的 HTML, 然后 Jekyll 就会帮你套入一个或一系列的布局中。在整个过程中你可以设置URL路径, 你的文本在布局中的显示样式等等。这些都可以通过纯文本编辑来实现，最终生成的静态页面就是你的成品了。 一个基本的 Jekyll 网站的目录结构一般是像这样的： 1234567891011121314151617181920.├── _config.yml ├── _includes | ├── footer.html | └── header.html ├── _layouts | ├── default.html | ├── post.html | └── page.html ├── _posts | └── 2017-08-01-welcome-to-jekyll.markdown ├── _sass | ├── _base.scss | ├── _layout.scss | └── _syntax-highlighting.scss ├── about.md ├── css | └── main.scss ├── feed.xml └── index.html 这些目录结构以及具体的作用可以参考 进入 _config.yml 里面，修改成你想看到的信息，重新 jekyll server ，刷新浏览器就可以看到你刚刚修改的信息了。 到此，博客初步搭建算是完成了， 编写文章 所有的文章都是 _posts 目录下面，文章格式为 mardown 格式，文章文件名可以是 .mardown 或者 .md。 编写一篇新文章很简单，你可以直接从 _posts/ 目录下复制一份出来 2017-08-01-welcome-to-myblog.md ，修改名字为 2017-08-01-article1.markdown ，注意：文章名的格式前面必须为 2017-08-01- ，日期可以修改，但必须为 年-月-日- 格式，后面的 article1 是整个文章的连接 URL，如果文章名为中文，那么文章的连接URL就会变成这样的：%E6%90%AD%E5， 所以建议文章名最好是英文的或者阿拉伯数字。 双击 2017-08-01-article1.markdown 打开 参考资源 潘柏信-Jekyll搭建个人博客 GitHub Pages官方文档 一步步在GitHub上创建博客主页","categories":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"http://example.com/tags/Jekyll/"}],"keywords":[{"name":"其它","slug":"其它","permalink":"http://example.com/categories/其它/"}]}]}